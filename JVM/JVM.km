{
    "root": {
        "data": {
            "id": "d2gk685jog80",
            "created": 1720076336269,
            "text": "JVM"
        },
        "children": [
            {
                "data": {
                    "id": "d2gk8gqqoyo0",
                    "created": 1720076511693,
                    "text": "自動內存管理",
                    "layout_mind_offset": {
                        "x": -78,
                        "y": -75
                    },
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "id": "d2gkg028cb40",
                            "created": 1720077102296,
                            "text": "Chapter2 Java內存區域與內存溢出異常",
                            "expandState": "collapse"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d2gkiegtjl40",
                                    "created": 1720077290381,
                                    "text": "2.1 概述"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d2gkiimqanc0",
                                    "created": 1720077299445,
                                    "text": "2.2 運行時數據區域",
                                    "expandState": "expand"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d2gkrqr9o4g0",
                                            "created": 1720078022412,
                                            "text": "2.1.1 程序計數器",
                                            "note": "1. 線程私有\n2. 字節碼解釋器通過改變這個計數器的值來選取下一條需要執行的字節碼指令\n3. 分支、循環、跳轉、異常處理、線程恢復等需要依賴這個計數器完成\n4. 執行java方法時，計數器的值是正在執行指令的地址，執行native方法時，計數器的值為Undefined\n5. 此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2glwm5mz6o0",
                                            "created": 1720081225327,
                                            "text": "2.2.2 Java虛擬機棧",
                                            "note": "1. 線程私有，生命週期與線程相同\n2. 虛擬機棧用於存儲被執行的方法，每個方法被執行，就會在棧中創建一個棧幀，方法執行完成，對應的棧幀會出棧\n3. 棧幀包含：局部變量表、操作數棧、動態連接、方法出口等信息\n4. 局部變量表存放編譯期可知的基本數據類型（boolean、byte、char、short、int、float、long、double）、對象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）\n5. 局部變量表的存儲空間以變量槽（Slot）來表示，64位長度的long和double佔2個變量槽，其餘數據類型只佔1個，局部變量表所需空間大小在編譯期確定，並且運行期不會改變，此處的大小為變量槽個數，具體一個變量槽多大由虛擬機實現決定\n6. 線程請求棧深大於虛擬機允許的棧深，則拋出StackOverflowError異常；若虛擬機棧可擴容，當棧擴展時無法申請到足夠內存則拋出OutOfMemoryError異常（HotSpot虛擬機的棧容量不可動態擴展，但若申請時就失敗，仍有可能拋出OOM）"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gm7qpu6e80",
                                            "created": 1720082097262,
                                            "text": "2.2.3 本地方法棧",
                                            "note": "1. 虛擬機棧為java方法服務，本地方法棧為虛擬機使用到的本地方法服務\n2. HotSpot虛擬機將虛擬機棧和本地方法棧合二為一\n3. 線程私有"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gmebmd69s0",
                                            "created": 1720082612949,
                                            "text": "2.2.4 Java堆",
                                            "note": "1. Java堆用於存儲對象\n2. 堆中可劃分多個線程私有的分配緩衝區（Thread Local Allocation Buffer，TLAB），以提升對象分配效率\n3. 堆物理上可不連續，邏輯上應該連續（大對象出於簡單和存儲高效考慮，可能會要求連續的存儲空間，如數組）\n4. java堆可擴展（-Xmx、-Xms設定）\n5. 線程共享\n6. 如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gmm0td00w0",
                                            "created": 1720083216341,
                                            "text": "2.2.5 方法區",
                                            "note": "1. 線程共享\n2. jdk8開始啟用永久代，改為使用元空間（Metaspace）實現方法區\n3. jdk8開始方法區在本地內存中\n4. 方法區的內存回收較為困難，主要是常量池的回收及類型的卸載，回收效果難令人滿意\n5. 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据\n6. 如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gmyibnihs0",
                                            "created": 1720084194822,
                                            "text": "2.2.6 運行時常量池",
                                            "note": "1. 運行時常量池是方法區的一部分\n2. class文件包含：類的版本、字段、方法、接口、常量池表\n3. 常量池表用於存放編譯期生成的各種字面量和符號引用，在類加載後存放到方法區的運行時常量池\n4. 運行期也可以將新的常量放入運行時常量池，即使沒有預置在class文件中，如String.intern()\n5. 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gn6a6srp40",
                                            "created": 1720084804028,
                                            "text": "2.2.7 直接內存",
                                            "note": "1. 直接內存不是虛擬機運行時數據區的一部分，也不是Java虛擬機規範中定義的內存區域\n2. JDK1.4新增的NIO可以使用Native函數庫直接分配對外內存，再通過堆裡的DirectByteBuffer對象作為這塊內存的引用進行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n3. 直接內存不受堆大小控制"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d2gn961rvm80",
                                    "created": 1720085030109,
                                    "text": "2.3 HotSpot虛擬機對象探秘",
                                    "layout_right_offset": {
                                        "x": -16,
                                        "y": -1
                                    }
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d2gnh0jzu080",
                                            "created": 1720085645063,
                                            "text": "2.3.1 對象的創建",
                                            "note": "1. 虛擬機接受到new指令\n2. 檢查指令參數是否能在常量池定位一個符號引用\n3. 檢查該符號引用代表的類是否已被加載、解析初始化過，沒有則執行類加載\n4. 類加載通過後開始為新生對象分配內存，所需內存大小在類加載完成即可確定。內存分配可使用指針碰撞（Bump The Pointer）或空閒列表（Free List）的方式\n5. 除分配內存外，還需要考慮並發問題：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。\n解決方式：\n1. CAS+失敗重試（虛擬機採用這種方式）\n2. 把內存分配根據線程劃分在不同的內存空間中，線程緩衝區使用完了再同步（TLAB）\n\n6. 內存分配完成後，便要分配到的內存（不包括對相投）初始化為零值，，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。保證了java代碼中實例字段即使不賦初值也可使用\n\n7. 對象頭設定，如：類信息、對象哈希碼（調用Object::hashCode()才計算）、GC分代年齡等\n\n8. 執行類的構造函數\n\n\n\n\n",
                                            "layout_right_offset": {
                                                "x": 7,
                                                "y": 1.5
                                            }
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d2i2vs5xgao0",
                                                    "created": 1720230678866,
                                                    "text": "內存分配方式",
                                                    "note": "1. 指針碰撞（Bump The Pointer)\n> 針對規整的內存，所有使用過的內存放在一邊，空閒的內存在另一邊，中間放一個指針作為分界點指示器，此時內存分配就是指針向空閒空間方向移動對象大小的距離\n\n2. 空閒列表（Free List）\n> 針對不規整內存（已使用和空閒內存交錯在一起），虛擬機維護一個空閒列表，記錄哪些內存塊可用，分配時從列表中找出一塊足夠大的空間劃分給對象實例，並更新列表記錄\n\n選擇指針碰撞還是空閒列表取決於java堆是否規整。java堆是否規整由所採用的垃圾收集器是否帶有空間壓縮能力決定。\n如Serial、ParNew有壓縮整理過程，系統採用的分配算法是指針碰撞，簡單高效\nCMS收集器基於清除算法，理論上只能採用較為複雜的空閒列表方式分配內存\n\n强调“理论上”是因为在CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作Linear\nAllocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指\n针碰撞方式来分配。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d2i3uez011s0",
                                                    "created": 1720233392895,
                                                    "text": "內存分配並發問題解決"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d2i3vkf36k00",
                                                            "created": 1720233483116,
                                                            "text": "線程分配緩衝",
                                                            "note": "本地線程分配緩衝（Thread Local Allocation Buffer,TLAB）\n線程需要分配內存時，優先在各自線程的分配緩衝區中分配，只有本地緩衝區用完了，分配新的緩存區時才需要同步鎖定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d2i3vqcgmxs0",
                                                            "created": 1720233496018,
                                                            "text": "CAS+失敗重試",
                                                            "note": "什么是CAS（CAS屬於樂觀鎖）？\nCAS是一种非阻塞式并发控制技术，它主要用于解决多个线程同时访问同一个共享资源时可能出现的竞争条件问题。为了保证数据的一致性和正确性，我们通常需要采取同步机制来对共享资源进行加锁。但是，传统的锁机制在高并发场景下会带来严重的性能问题，因为所有线程都需要等待锁的释放才能进行操作，这就会导致大量线程的阻塞和唤醒，进而降低了系统的并发性能。\n为了解决这个问题，CAS应运而生。它是一种无锁的同步机制，可以在不使用锁的情况下实现数据的同步和并发控制。CAS的核心思想是：在执行操作之前，先比较当前内存中的值是否等于期望值，如果相等，则执行修改操作；如果不相等，则不执行修改操作，继续进行比较，直到内存中的值与期望值相等为止。这个过程中不会出现线程的阻塞和唤醒，因此可以提高系统的并发性能。\n\n* 开销问题\n>在 CAS 期间，线程是不会休息的，线程如果长时间无法提交，内部就一直在进行自旋，这样就会产生比较大的内存开销\nCAS 只能够保证一个共享变量的原子操作\nCAS 只能保证对一个内存地址进行原子操作，所以说使用范围会有一定限制\n例如：如果在执行 a+1 的下面加上，b+1，c +1，这种情况就会出现问题，这种时候反而使用 Syn 比较方便\n多個變量的院子操作可考慮Java的AtomicReference"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4469byk27k0",
                                            "created": 1726130681507,
                                            "text": "2.3.2 對象的內存佈局"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4469kyefq80",
                                                    "created": 1726130701089,
                                                    "text": "對象頭"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d446b13vp140",
                                                            "created": 1726130814613,
                                                            "text": "MarkWord",
                                                            "note": "MarkWord用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特。\nMark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根\n据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态\n下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年\n龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标\n记、可偏向）下对象的存储内容參考MarkDown2.3.2內容。"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d446b1evkpc0",
                                                            "created": 1726130815277,
                                                            "text": "類型指針",
                                                            "note": "指向類型元數據，用以確定對象的類型信息。（不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话\n说，查找对象的元数据信息并不一定要经过对象本身）\n如果該對象是java數組，則對象頭還需存放數組的長度信息（因為如果數組的長度是不定的，無法通過元數據推斷數組大小）"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            },
                                            {
                                                "data": {
                                                    "id": "d4469oqtg4w0",
                                                    "created": 1726130709337,
                                                    "text": "實例數據",
                                                    "note": "該部分是對象真正存儲的有效信息，包含代碼中定義的各種類型的字段，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。\n存储顺序会\n受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。\nHotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary\nObject Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存\n放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的\n+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空\n隙之中，以节省出一点点空间。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4469p1nzeo0",
                                                    "created": 1726130709993,
                                                    "text": "對齊填充",
                                                    "note": "对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作\n用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是\n任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者\n2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d446w5m8u000",
                                            "created": 1726132470078,
                                            "text": "2.3.3 對象的訪問定位",
                                            "note": "1. 句柄訪問的優勢在於穩定的句柄地址，即使對象被移動，也只需要修改句柄池中實例數據的指針\n2. 直接訪問的優勢在於速度更快，因為節省了一次對象定位的時間\nHotSpot主要使用直接訪問的方式進行對象訪問"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4471l61g9s0",
                                                    "created": 1726132895747,
                                                    "text": "句柄訪問",
                                                    "note": "如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就\n是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息其结构參考MarkDown。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4471lhgwp40",
                                                    "created": 1726132896438,
                                                    "text": "直接訪問",
                                                    "note": "如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关\n信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问\n的开销，其结构參考MarkDown。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d4475b2gdc00",
                            "created": 1726133187219,
                            "text": "Chapter3 垃圾收集器與內存分配策略",
                            "note": "·哪些内存需要回收？\n·什么时候回收？\n·如何回收？",
                            "expandState": "collapse"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d4476tkmt680",
                                    "created": 1726133305865,
                                    "text": "3.2 對象存活算法",
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4478pfin3c0",
                                            "created": 1726133453576,
                                            "text": "3.2.1 引用計數法",
                                            "note": "在对象中添加一个引用计数器，每当有一个地方\n引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可\n能再被使用的。\n缺點：\n这个看似简单\n的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数\n就很难解决对象之间相互循环引用的问题。举个简单的例子，请看代码清单3-1中的testGC()方法：对象objA和objB都有字段instance，赋值令\nobjA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已\n经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也\n就无法回收它们。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d447a11t29k0",
                                            "created": 1726133557233,
                                            "text": "3.2.2 可達性分析算法",
                                            "note": "当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是\n通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过\n一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过\n程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，\n或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d44u4w0rmtc0",
                                                    "created": 1726198039993,
                                                    "text": "固定GC Roots",
                                                    "note": "·在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。\n·在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。\n·在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。\n·在本地方法栈中JNI（即通常所说Native方法）引用的对象。\n·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。\n·所有被同步锁（synchronized关键字）持有的对象。\n·反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44u7zq5bxc0",
                                                    "created": 1726198283151,
                                                    "text": "額外GC Roots",
                                                    "note": "除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不\n同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。譬如后文将会提到的分代收集\n和局部回收（Partial GC），如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生\n代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不\n可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引\n用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确\n性。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d44ub10mkg00",
                                            "created": 1726198521054,
                                            "text": "3.2.3 引用分類",
                                            "note": "无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可\n达，判定对象是否存活都和“引用”离不开关系。在JDK 1.2版之前，Java里面的引用是很传统的定义：\n如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表\n某块内存、某个对象的引用。这种定义并没有什么不对，只是现在看来有些过于狭隘了，一个对象在\n这种定义下只有“被引用”或者“未被引用”两种状态，对于描述一些“食之无味，弃之可惜”的对象就显\n得无能为力。譬如我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空\n间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的应\n用场景。\n在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软\n引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强\n度依次逐渐减弱。"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d44ubpq1j6o0",
                                                    "created": 1726198574833,
                                                    "text": "強引用",
                                                    "note": "·强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回\n收掉被引用的对象。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44ubpzg0rk0",
                                                    "created": 1726198575402,
                                                    "text": "軟引用",
                                                    "note": "·软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内\n存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，\n才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44ubq55dbs0",
                                                    "created": 1726198575747,
                                                    "text": "弱引用",
                                                    "note": "·弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只\n能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只\n被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44ubqanfl40",
                                                    "created": 1726198576079,
                                                    "text": "虛引用",
                                                    "note": "·虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的\n存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚\n引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供\n了PhantomReference类来实现虚引用。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d44wznrvle80",
                                            "created": 1726206093550,
                                            "text": "3.2.4 GC對象回收流程"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d44x0cvwo9k0",
                                                    "created": 1726206148214,
                                                    "text": "1. 判定對象不可達",
                                                    "note": "可达性分析算法中判定为不可达的对象"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44x0hfb41k0",
                                                    "created": 1726206158094,
                                                    "text": "2. 第一次標記",
                                                    "note": "如果对象在进行可达性分析后发现没\n有与GC Roots相连接的引用链，那它将会被第一次标记"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44x3bjnyr40",
                                                    "created": 1726206380389,
                                                    "text": "3. 篩選是否需要執行finalize()",
                                                    "note": "随后进行一次筛选，筛选的条件是此对象是\n否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用\n过，那么虚拟机将这两种情况都视为“没有必要执行”。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44x5wl8y680",
                                                    "created": 1726206582926,
                                                    "text": "4. 需要執行finalize()對象放入F-Queue",
                                                    "note": "如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的\n队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()\n方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。\n这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导\n致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44x2ckoe0o0",
                                                    "created": 1726206304263,
                                                    "text": "5. 執行對象的finalize()",
                                                    "note": "对象的finalize()方法都只会被系统自动调用一次，如果对象面临\n下一次回收，它的finalize()方法不会被再次执行;\n还有一点需要特别说明，上面关于对象死亡时finalize()方法的描述可能带点悲情的艺术加工，笔\n者并不鼓励大家使用这个方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它并不能等同\n于C和C++语言中的析构函数，而是Java刚诞生时为了使传统C、C++程序员更容易接受Java所做出的一\n项妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为\n不推荐使用的语法。有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize()\n方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、\n更及时，所以笔者建议大家完全可以忘掉Java语言里面的这个方法。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44x0nj73740",
                                                    "created": 1726206171390,
                                                    "text": "6. 對F-Queue中的對象二次標記",
                                                    "note": "finalize()方法是对\n象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对\n象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己\n（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集\n合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d44ytwz3x0g0",
                                            "created": 1726211285613,
                                            "text": "3.2.5 回收方法区",
                                            "note": "有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚\n拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整\n实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集\n的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常\n可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回\n收成果往往远低于此。\n方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。回收废弃常量与回收\nJava堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池\n中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用\n常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且\n垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接\n口）、方法、字段的符号引用也与此类似。"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4519rhfxy80",
                                                    "created": 1726218169708,
                                                    "text": "廢棄的常量",
                                                    "note": "举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池\n中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用\n常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且\n垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接\n口）、方法、字段的符号引用也与此类似。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4519rt6pzk0",
                                                    "created": 1726218170418,
                                                    "text": "不再被使用的類",
                                                    "note": "判定一个类型是否属于“不再被使用的类”的条件，需要同时满足下面三个条件：\n* 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。\n* 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如\nOSGi、JSP的重加载等，否则通常是很难达成的。\n* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方\n法。\nJava虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是\n和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-\nXnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClass-Loading、-XX：\n+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在\nProduct版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版[1]的虚拟机支持。\n在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载\n器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压\n力。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d45og1s14ag0",
                                    "created": 1726283547829,
                                    "text": "3.3 垃圾收集算法",
                                    "note": "从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference\nCounting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接\n垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不\n把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。",
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d45oi282kjc0",
                                            "created": 1726283705527,
                                            "text": "3.3.1 分代收集理論"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d45oubl8vio0",
                                                    "created": 1726284666285,
                                                    "text": "1. 弱分代假說",
                                                    "note": "**绝大多数对象都是朝生夕灭的**\n"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d45ouf6n3jk0",
                                                    "created": 1726284674109,
                                                    "text": "2. 強分代假說",
                                                    "note": "**熬过越多次垃圾收集过程的对象就越难以消亡**\n強分代假說和弱分代假說奠定了多數立即收集器的設計原則：\n：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。\n朝生夕滅的對象集中放到一起，以較高頻率回收；難以消亡的對象放到一起，以較低頻率回收，这就同时兼顾了垃圾收集的时间开销和内存的空间有\n效利用。\n\njava堆劃分不同區域，引出了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分，因此針對不同區域的回收發展出了了“标记-复制算法”“标记-清除算\n法”“标记-整理算法”等针对性的垃圾收集算法"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d45oufua0gg0",
                                                    "created": 1726284675538,
                                                    "text": "3. 跨代引用假說",
                                                    "note": "**跨代引用相对于同代引用来说仅占极少数**\n跨代引用：新生代中的对象是完全有可\n能被老年代所引用的\n为了找出新生代中的存活对象，不得不在固定的GC Roots之外，再额外遍历整\n个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样[3]。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，引申出了跨代引用假說：**跨代引用相对于同代引用来说仅占极少数**\n依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录\n每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称\n为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会\n存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC\nRoots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数\n据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d45p2y4t7hk0",
                                                    "created": 1726285342270,
                                                    "text": "不同GC類型定義",
                                                    "note": "·部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：\n■新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。\n■老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单\n独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，\n读者需按上下文区分到底是指老年代的收集还是整堆收集。\n■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收\n集器会有这种行为。\n·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d45p3vupfqw0",
                                            "created": 1726285415670,
                                            "text": "3.3.2 標記-清除算法",
                                            "note": "如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回\n收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回\n收所有未被标记的对象。\n優點：\n1. 沒有後續的複製或整理動作，速度較快\n\n缺點：\n1. 執行效率不穩定，若java堆中有大量需要被回收的對象，這是必須進行大量標記和清除動作，导致标记和清除两个过\n程的执行效率都随对象数量增长而降低\n2. 內存空間碎片化問題：标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d45p91k468w0",
                                            "created": 1726285819911,
                                            "text": "3.3.3 標記-複製算法",
                                            "note": "为了解决标记-清除算法面对大量可回收对象时执行效率低\n的问题，1969年Fenichel提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用\n内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着\n的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存\n活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复\n制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有\n空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷\n也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一\n点\n现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，IBM公司曾有一项专门研\n究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集。因此\n并不需要按照1∶1的比例来划分新生代的内存空间。\n```\n“Appel式回收”\n針對對象朝生夕滅的特點，在1989年，Andrew Appel提出了一种更优化的半区复制分代策略：具体做法是把新生代分为一块较大的Eden空间和两块较小的\nSurvivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍\n然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空\n间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1\n```"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d45pev9f0v40",
                                                    "created": 1726286276388,
                                                    "text": "內存分配擔保",
                                                    "note": "在Appel式回收中，可能發生suvivor空間不足以存放一次Minor GC剩餘對象時，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d45pgrwc4h40",
                                            "created": 1726286425795,
                                            "text": "3.3.4 標記-整理算法",
                                            "note": "针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整\n理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可\n回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内\n存，\n标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的；\n移動存活對象會涉及對象引用的變更，這種操作必須全程暫停用戶應用進程才能進行（Stop The World）\n像標記-清除算法若不移動和整理存活對象，則空間碎片化問題稚嫩惡搞依賴更複雜的內存分配器和內存訪問器來解決\n但總的來說，移動對象對程序的吞吐量還是有益的（沒有空間碎片化問題，可順序分配對象空間）\nHotSpot虚拟机里面关注吞吐量的Parallel\nScavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从\n侧面印证这点。\n另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚\n拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经\n大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标\n记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。\n\n老年代對象存活概率較高，故老年代一般不能直接使用標記-複製算法"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d45rod3qchs0",
                                    "created": 1726292662724,
                                    "text": "3.4 HotSpot的算法細節實現",
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d45sayojbq00",
                                            "created": 1726294433706,
                                            "text": "3.4.1 根節點枚舉",
                                            "note": "固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如\n栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应\n用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检\n查以这里为起源的引用肯定得消耗不少时间。\n\n迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。因為根節點枚舉需要在一個一致性快照中執行才有意義，若一邊枚舉一邊引用不停變換，那麼枚舉是沒有意義的。即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。\n為避免一個不漏的從方法區查找GC Roots，HostSpot通過維護一組名為OoPMap（Ordinary Object Pointer，OOP）的數據結構來減少查找GC Roots的時間。。一旦类加载动作完成的时候，\nHotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（见第11章）过程中，也\n会在特定的位置记录下栈里和寄存器里哪些位置是引用，並記錄到OopMap中。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d45seunpjgw0",
                                            "created": 1726294738405,
                                            "text": "3.4.2 安全點"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4aync0evqo0",
                                                    "created": 1726820129535,
                                                    "text": "可以產生安全點的指令"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4aynl716800",
                                                    "created": 1726820149526,
                                                    "text": "中斷方式"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4aynq1jbfc0",
                                                    "created": 1726820160078,
                                                    "text": "主動式中斷性能"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4aymu4x9ps0",
                                            "created": 1726820090626,
                                            "text": "3.4.3 安全區域"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4ayojjoqbk0",
                                            "created": 1726820224302,
                                            "text": "3.4.4 記憶集與卡錶"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4aypluce600",
                                                    "created": 1726820307664,
                                                    "text": "概念及作用"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4ayr4d1za80",
                                                    "created": 1726820426342,
                                                    "text": "記憶集的精度"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4ayr9lbv5c0",
                                                    "created": 1726820437726,
                                                    "text": "卡錶"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4az4a9r8ag0",
                                            "created": 1726821457937,
                                            "text": "3.4.5 寫屏障"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4azvbw5rkw0",
                                                    "created": 1726823577301,
                                                    "text": "概念"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4azvfwd6740",
                                                    "created": 1726823586021,
                                                    "text": "卡錶何時變髒、誰來變髒"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4azw32oacg0",
                                                    "created": 1726823636468,
                                                    "text": "偽共享問題"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4b09eqpau80",
                                            "created": 1726824680600,
                                            "text": "3.4.6 並發的可達性分析"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4b3xhb0wrk0",
                                                    "created": 1726835030252,
                                                    "text": "用戶線程與GC線程並發產生的問題"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4b3xtyf2js0",
                                                    "created": 1726835057788,
                                                    "text": "引用變化導致對象消失問題"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4b3y8bloy00",
                                                    "created": 1726835089060,
                                                    "text": "對象消失條件"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4b3ydjmb4w0",
                                                    "created": 1726835100428,
                                                    "text": "解決對象消失方法"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d4b3yi4q9xs0",
                                                            "created": 1726835110412,
                                                            "text": "增量更新"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4b3yl650o00",
                                                            "created": 1726835117028,
                                                            "text": "原始快照"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d4blx6ak7o80",
                                    "created": 1726885786257,
                                    "text": "3.5 經典垃圾收集器",
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4blxexaq140",
                                            "created": 1726885805046,
                                            "text": "3.5.1 Serial收集器",
                                            "note": "新生代使用標記-複製算法\n老年代使用標記-整理算法\n\nGC階段需暫停用戶線程"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4blyt91ebs0",
                                            "created": 1726885914595,
                                            "text": "3.5.2 ParNew收集器",
                                            "note": "Serial收集器的改進版本\n新生代GC線程改為多線程並行\njdk9之後只能與CMS搭配使用（jdk9 CMS被標記為棄用）"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4bm4jwgu600",
                                            "created": 1726886364429,
                                            "text": "3.5.3 Parallel Scavenge收集器",
                                            "note": "Parallel Scavenge的诸多特性从表面上看和ParNew非常相似"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4bm7e65afc0",
                                                    "created": 1726886587046,
                                                    "text": "目標",
                                                    "note": "目標：達到一個可控制的吞吐量"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4bm7hjt6dk0",
                                                    "created": 1726886594403,
                                                    "text": "重要參數",
                                                    "note": "Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间\n的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。\n\n\n\nParallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得我们关注。这是一\n个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区\n的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数\n了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时\n间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）[1]。如果读\n者对于收集器运作不太了解，手工优化存在困难的话，使用Parallel Scavenge收集器配合自适应调节策\n略，把内存管理的调优任务交给虚拟机去完成也许是一个很不错的选择。只需要把基本的内存数据设\n置好（如-Xmx设置最大堆），然后使用-XX：MaxGCPauseMillis参数（更关注最大停顿时间）或-\nXX：GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就\n由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4bm97mlm3k0",
                                            "created": 1726886729532,
                                            "text": "3.5.4 Serial Old收集器",
                                            "note": "Serial收集器的老年代版本\nGC階段需暫停用戶線程\n\n它也可能有两种用\n途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，另外一种就是作为CMS\n收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4bmbxmvm000",
                                            "created": 1726886942874,
                                            "text": "3.5.5 Parralel Old收集器",
                                            "note": "Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实\n现。\n\nParallel Scavenge加Parallel Old收集器為吞吐量優先組合\n在注重\n吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑；"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4bmdeejvjk0",
                                            "created": 1726887057740,
                                            "text": "3.5.6 CMS收集器"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4bmngnjf1k0",
                                                    "created": 1726887846278,
                                                    "text": "目標",
                                                    "note": "CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4bmoxiqsqg0",
                                                    "created": 1726887961358,
                                                    "text": "運作過程",
                                                    "note": "1）初始标记（CMS initial mark）\n2）并发标记（CMS concurrent mark）\n3）重新标记（CMS remark）\n4）并发清除（CMS concurrent sweep）\n\n\n\n其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC\nRoots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对\n象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重\n新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的\n标记记录（详见3.4.6节中关于增量更新的讲解），这个阶段的停顿时间通常会比初始标记阶段稍长一\n些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的\n对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\n由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一\n起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4bmnj348x40",
                                                    "created": 1726887851574,
                                                    "text": "重要參數",
                                                    "note": "如果在实际应用中老年代增长并不是太快，可以适当调高参数-XX: CMSInitiatingOccu-pancyFraction的值\n来提高CMS的触发百分比，降低内存回收频率，获取更好的性能"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4bmnnn1u3c0",
                                                    "created": 1726887861486,
                                                    "text": "優缺點",
                                                    "note": "首先，CMS收集器对处理器资源非常敏感。事实上，面向并发设计的程序都对处理器资源比较敏\n感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计\n算能力）而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量\n+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的\n处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，\nCMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能\n力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。为了缓解这种情况，虚拟机提\n供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器变种，\n所做的事情和以前单核处理器年代PC机操作系统靠抢占式多任务来模拟多核并行多任务的思想一样，\n是在并发标记、清理的时候让收集器线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源的\n时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得较少一些，直观感受是速度变\n慢的时间更多了，但速度下降幅度就没有那么明显。实践证明增量式的CMS收集器效果很一般，从\nJDK 7开始，i-CMS模式已经被声明为“deprecated”，即已过时不再提倡用户使用，到JDK 9发布后i-\nCMS模式被完全废弃。\n然后，由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current Mode\nFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶\n段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分\n垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集\n时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样也是由于在垃圾收集阶段用户线程还需要持续运\n行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待\n到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK\n5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果\n在实际应用中老年代增长并不是太快，可以适当调高参数-XX：CMSInitiatingOccu-pancyFraction的值\n来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动\n阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满\n足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不\n得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，\n但这样停顿时间就很长了。所以参数-XX：CMSInitiatingOccupancyFraction设置得太高将会很容易导致\n大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。\n还有最后一个缺点，在本节的开头曾提到，CMS是一款基于“标记-清除”算法实现的收集器，如果\n读者对前面这部分介绍还有印象的话，就可能想到这意味着收集结束时会有大量空间碎片产生。空间\n碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找\n到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。为了解决这个问题，\nCMS收集器提供了一个-XX：+UseCMS-CompactAtFullCollection开关参数（默认是开启的，此参数从\nJDK 9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个\n内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片问题是解\n决了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBefore-\nCompaction（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量\n由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表\n示每次进入Full GC时都进行碎片整理）。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4bmytfynbk0",
                                            "created": 1726888736124,
                                            "text": "3.5.7 Garbage First收集器",
                                            "note": "JDK 9发布之\n日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则\n沦落至被声明为不推荐使用（Deprecate）的收集器\n\n\n",
                                            "expandState": "collapse"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4bn1g9b10g0",
                                                    "created": 1726888942516,
                                                    "text": "目標",
                                                    "note": "Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集\n器面向局部收集的设计思路和基于Region的内存布局形式\n\n设计者们希望做出一款能够建立起“停顿时间模型”（Pause\nPrediction Model）的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段\n内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，这几乎已经是实时Java（RTSJ）的中\n软实时垃圾收集器特征了。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4bn601gov40",
                                                    "created": 1726889299034,
                                                    "text": "特性",
                                                    "note": "G1开创的基于Region的堆内存布局是它能够实现这个目标的关键\n\n虽然G1也仍是遵循分代收集理\n论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的\n分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以\n根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的\nRegion采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的\n旧对象都能获取很好的收集效果。\n\nRegion中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个\nRegion容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设\n定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，\n将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代\n的一部分来进行看待，\n\n虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区\n域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作\n为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免\n在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃\n圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一\n个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默\n认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。\n这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获\n取尽可能高的收集效率。"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d4bn9yw904w0",
                                                            "created": 1726889609999,
                                                            "text": "基於Region劃分堆空間"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4bn9sdawvs0",
                                                            "created": 1726889595792,
                                                            "text": "分代收集"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4bnad211vk0",
                                                            "created": 1726889640823,
                                                            "text": "Humongous區域"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4bnaqt87qg0",
                                                            "created": 1726889670766,
                                                            "text": "根據回收價值選擇性回收Region"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4bnbltyt880",
                                                            "created": 1726889738291,
                                                            "text": "雙向卡錶",
                                                            "note": "将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？解决的思\n路我们已经知道（见3.3.1节和3.4.4节）：使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记\n忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region\n指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一\n种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这\n种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更\n复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃\n圾收集器有着更高的内存占用负担。根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额\n外内存来维持收集器工作。"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            },
                                            {
                                                "data": {
                                                    "id": "d4bn4vrf7uo0",
                                                    "created": 1726889211356,
                                                    "text": "重要參數",
                                                    "note": "每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂\n\n-XX：MaxGCPauseMillis 设定允许的收集停顿时间，默认值是200毫秒，G1會根據該設定优先处理回收价值收益最大的那些Region"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4bqwentpg00",
                                                    "created": 1726899831659,
                                                    "text": "關鍵問題"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d4bqwm4ntmg0",
                                                            "created": 1726899847915,
                                                            "text": "在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？",
                                                            "note": "1. 原始快照保證並發標記的正確性\n2. G1为每一个Region设\n计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过\n程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。\n3. 如果内存回收的速度赶不上内存分配的速度，\nG1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4bqygbb8v40",
                                                            "created": 1726899991984,
                                                            "text": "怎样建立起可靠的停顿预测模型？",
                                                            "note": "1. 通过-XX：MaxGCPauseMillis参数指定的停顿时间\n2. 在垃圾收集过程中，G1收集器会记\n录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得\n出平均值、标准偏差、置信度等统计信息，然后通过这些信息预测现在开始回收的话，由\n哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            },
                                            {
                                                "data": {
                                                    "id": "d4bqz85a7o80",
                                                    "created": 1726900052570,
                                                    "text": "運作過程",
                                                    "note": "* 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS\n指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要\n停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际\n并没有额外的停顿。\n\n* 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆\n里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以\n后，还要重新处理SATB记录下的在并发时有引用变动的对象。\n\n* 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留\n下来的最后那少量的SATB记录。\n\n* 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回\n收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region\n构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧\nRegion的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行\n完成的。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4br8av4py00",
                                                    "created": 1726900763764,
                                                    "text": "與CMS對比"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d4br8gymqag0",
                                                            "created": 1726900777036,
                                                            "text": "卡錶",
                                                            "note": "CMS只有一個老年代，只需要維護一份卡錶記錄跨代引用\nG1每個region都要維護卡錶，而且為雙向卡錶"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4br8j9kc8o0",
                                                            "created": 1726900782051,
                                                            "text": "寫屏障",
                                                            "note": "CMS使用寫後屏障來維護卡錶\nG1使用寫後屏障維護卡錶，使用寫前屏障維護並發標記時對象引用的變化\n\nCMS的寫屏障是同步操作\nG1因寫屏障操作複雜，採用類似隊列的方式，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4brc6p7tzk0",
                                                            "created": 1726901068156,
                                                            "text": "並發標記階段差異",
                                                            "note": "CMS採用增量更新來處理並發期間的引用變更\nG1採用原始快照方式"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d4brg2lsnm80",
                                    "created": 1726901372698,
                                    "text": "3.6 低延遲垃圾收集器",
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4ebmmrkeqw0",
                                            "created": 1727161428879,
                                            "text": "3.6.1 Shenandoah收集器",
                                            "layout_right_offset": {
                                                "x": -31,
                                                "y": 0
                                            }
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4ebnyb2huw0",
                                                    "created": 1727161532367,
                                                    "text": "與G1異同"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d4ebo3l66540",
                                                            "created": 1727161543862,
                                                            "text": "同",
                                                            "note": "Shenandoah反而更像是G1\n的下一代继承者，它们两者有着相似的堆内存布局，在初始标记、并发标记等许多阶段的处理思路上\n都高度一致，甚至还直接共享了一部分实现代码，这使得部分对G1的打磨改进和Bug修改会同时反映\n在Shenandoah之上，而由于Shenandoah加入所带来的一些新特性，也有部分会出现在G1收集器中，譬\n如在并发失败后作为“逃生门”的Full GC[3]，G1就是由于合并了Shenandoah的代码才获得多线程Full\nGC的支持。\n\nShenandoah也是使用基于Region的堆内存布局，同样\n有着用于存放大对象的Humongous Region，默认的回收策略也同样是优先处理回收价值最大的\nRegion"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4ebo6qg0600",
                                                            "created": 1727161550711,
                                                            "text": "異",
                                                            "note": "1. 最重要的当然是支持并发的整理算法，G1的回收阶段是可以多线程并行的，但却不能与用户线程并发\n\n2. Shenandoah（截止jdk13發佈之時）是默认不使用分代收集的，换言之，不会有专门的新生代Region或者老年代Region的存在，没有实现分代，并不是说分代对Shenandoah没有价值，这更多是出于性价比的权衡，基于工作量上的考虑而将其放到优先级较低的位置上\n\n3. Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（ConnectionMatrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题（见3.4.4节）的发生概率"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            },
                                            {
                                                "data": {
                                                    "id": "d4ebrmad3340",
                                                    "created": 1727161819660,
                                                    "text": "工作過程",
                                                    "note": "`初始标记`（Initial Marking）：与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍\n是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。\n`并发标记`（Concurrent Marking）：与G1一样，遍历对象图，标记出全部可达的对象，这个阶段\n是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。\n`最终标记`（Final Marking）：与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值\n最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停\n顿。\n`并发清理`（Concurrent Cleanup）：这个阶段用于清理那些整个区域内连一个存活对象都没有找到\n的Region（这类Region被称为Immediate Garbage Region）。\n`并发回收`（Concurrent Evacuation）：并发回收阶段是Shenandoah与之前HotSpot中其他收集器的\n核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之\n中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进\n行的话，就变得复杂起来了。其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象\n进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对\n象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通\n过读屏障和被称为“Brooks Pointers”的转发指针来解决（讲解完Shenandoah整个工作过程之后笔者还要\n再回头介绍它）。并发回收阶段运行的时间长短取决于回收集的大小。\n`初始引用更新`（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指\n向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未\n做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收\n集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的\n停顿。\n`并发引用更新`（Concurrent Update Reference）：真正开始进行引用更新操作，这个阶段是与用户\n线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它\n不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为\n新值即可。\n`最终引用更新`（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GC Roots\n中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。\n`并发清理`（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已\n再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收\n这些Region的内存空间，供以后新对象分配使用。\n以上对Shenandoah收集器这九个阶段的工作过程的描述可能拆分得略为琐碎，读者只要抓住其中\n三个最重要的并发阶段（并发标记、并发回收、并发引用更新），就能比较容易理清Shenandoah是如\n何运作的了。图3-16[5]中黄色的区域代表的是被选入回收集的Region，绿色部分就代表还存活的对\n象，蓝色就是用户线程可以用来分配对象的内存Region了。图3-16中不仅展示了Shenandoah三个并发阶\n段的工作过程，还能形象地表示出并发标记阶段如何找出回收对象确定回收集，并发回收阶段如何移\n动回收集中的存活对象，并发引用更新阶段如何将指向回收集中存活对象的所有引用全部修正，此后\n回收集便不存在任何引用可达的存活对象了。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4ecgwatmhc0",
                                                    "created": 1727163800560,
                                                    "text": "並行收集",
                                                    "expandState": "expand"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d4ech3slpuo0",
                                                            "created": 1727163816872,
                                                            "text": "內存保護陷阱",
                                                            "note": "在被移动对象原有的内存上设置保护陷阱（Memory\nProtection Trap），一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中段，进入预设好的异\n常处理器中，再由其中的代码逻辑把访问转发到复制后的新对象上。虽然确实能够实现对象移动与用\n户线程并发，但是如果没有操作系统层面的直接支持，这种方案将导致用户态频繁切换到核心态，\n代价是非常大的，不能频繁使用"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4ebz7q5vz40",
                                                            "created": 1727162414877,
                                                            "text": "BrooksPointer（轉發指針）",
                                                            "note": "在原有对象布局结构的最前面统一增加一个\n新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己\n\n从结构上来看，Brooks提出的转发指针与某些早期Java虚拟机使用过的句柄定位（关于对象定位\n详见第2章）有一些相似之处，两者都是一种间接性的对象访问方式，差别是句柄通常会统一存储在专\n门的句柄池中，而转发指针是分散存放在每一个对象头前面\n\n有了转发指针之后，有何收益暂且不论，所有间接对象访问技术的缺点都是相同的，也是非常显\n著的——每次对象访问会带来一次额外的转向开销，尽管这个开销已经被优化到只有一行汇编指令的\n程度\n\n转发指针加入后带来的收益自然是当对象拥有了一份新的副本时，只需要修\n改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转\n发到新的副本上。这样只要旧对象的内存仍然存在，未被清理掉，虚拟机内存中所有通过旧引用地址\n访问的代码便仍然可用，都会被自动转发到新对象上继续工作"
                                                        },
                                                        "children": [
                                                            {
                                                                "data": {
                                                                    "id": "d4ecjbwb7ps0",
                                                                    "created": 1727163991239,
                                                                    "text": "線程競爭問題",
                                                                    "note": "1）收集器线程复制了新的对象副本；\n2）用户线程更新对象的某个字段；\n3）收集器线程更新转发指针的引用值为新副本地址。\n如果不做任何保护措施，让事件2在事件1、事件3之间发生的话，将导致的结果就是用户线程对对\n象的变更发生在旧对象上，所以这里必须针对转发指针的访问操作采取同步措施，让收集器线程或者\n用户线程对转发指针的访问只有其中之一能够成功，另外一个必须等待，避免两者交替进行。实际上\nShenandoah收集器是通过比较并交换（Compare And Swap，CAS）操作[8]来保证并发时对象的访问正\n确性的"
                                                                },
                                                                "children": []
                                                            },
                                                            {
                                                                "data": {
                                                                    "id": "d4ecjlo3wrk0",
                                                                    "created": 1727164012511,
                                                                    "text": "執行效率",
                                                                    "note": "转发指针另一点必须注意的是执行频率的问题，尽管通过对象头上的Brooks Pointer来保证并发时\n原对象与复制对象的访问一致性，这件事情只从原理上看是不复杂的，但是“对象访问”这四个字的分\n量是非常重的，对于一门面向对象的编程语言来说，对象的读取、写入，对象的比较，为对象哈希值\n计算，用对象加锁等，这些操作都属于对象访问的范畴，它们在代码中比比皆是，要覆盖全部对象访\n问操作，Shenandoah不得不同时设置读、写屏障去拦截。\n\n為避免大量的讀屏障引起的性能開銷，计划在JDK 13中将Shenandoah的内存屏障模型改\n进为基于引用访问屏障（Load Reference Barrier）[10]的实现，所谓“引用访问屏障”是指内存屏障只拦\n截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写，这能够\n省去大量对原生类型、对象比较、对象加锁等场景中设置内存屏障所带来的消耗"
                                                                },
                                                                "children": []
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4edx5x8lm80",
                                            "created": 1727167896443,
                                            "text": "3.6.2 ZGC收集器"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d4brw98vw680",
                                    "created": 1726902640982,
                                    "text": "垃圾收集器變更史",
                                    "note": "* JDK11\n1. 新增Epsilon收集器，只分配內存，不回收內存，內存耗盡則關閉JVM\n2. 新增ZGC(實驗性)\n\n* JDK12\n1. 新增Shenandoah收集器（實驗性）\n\n* JDK13\n1. 優化ZGC：未使用的堆內存歸還給操作系統\n\n* JDK14\n1. 通過實現NUMA-aware內存分配機制，優化G1在大機器（多處理器，NUMA架構）上的內存分配\n2. 移除CMS垃圾收集器\n3. ZGC on macOS\n4. ZGC on Windows\n5. 將Parallel Scavenge + SerialOld組合標記為已棄用\n\n* JDK15\n1. ZGC由實驗特性修改為生產特性\n2. Shenandoah由實驗特性修改為生產特性\n\n* JDK16\n1. ZGC thread-stack processing由安全點中處理改為並發處理\n\n* JDK21\n1. 擴展ZGC對不同年代的新生代和老年代對象的維護，達到更頻繁收集新生代對象的目的，從而優化程式性能\n\n* JDK22\n1. G1新增Region固定功能，通過將大對象固定在某個Region，減少大對象的移動，實現降低延遲的效果\n\n* JDK23\n1. 將ZGC的默認模式改為分代模式，並將非分代模式置為棄用，以在將來版本中將其移除"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d4g2acbankw0",
                                    "created": 1727338195682,
                                    "text": "3.7 選擇合適的垃圾收集器"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d4g2akmpazk0",
                                    "created": 1727338213786,
                                    "text": "3.8 實戰：內存分配與回收策略",
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4g2j4fnou00",
                                            "created": 1727338883809,
                                            "text": "3.8.1 對象優先在Eden分配",
                                            "note": "\n大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC\n\n-XX：+PrintGCDetails 打印GC日誌參數"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4g2ka8rb340",
                                            "created": 1727338974816,
                                            "text": "3.8.2 大對象直接進入老年代",
                                            "note": "了-XX：PretenureSizeThreshold\n参数，指定大于该设置值的对象直接在老年代分配，只对Serial和ParNew两款新生代收集器有效"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4g2lxxngzc0",
                                            "created": 1727339104752,
                                            "text": "3.8.3 长期存活的对象将进入老年代"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4g2mtj3m9c0",
                                            "created": 1727339173529,
                                            "text": "3.8.4 动态对象年龄判定",
                                            "note": "为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到-\nXX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于\nSurvivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：\nMaxTenuringThreshold中要求的年龄。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4g2rf3ba5c0",
                                            "created": 1727339533920,
                                            "text": "3.8.5 空间分配担保",
                                            "note": "在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总\n空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-\nXX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允\n许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大\n于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。\n\n\nJDK 6 Update 24之\n后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行\nMinor GC，否则将进行Full GC。\n-XX：HandlePromotionFailure不再有效"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d4g2ueq8xjc0",
                            "created": 1727339768223,
                            "text": "Chapter4 虛擬機性能監控、故障處理工具",
                            "note": "|a|b|\n|--|--|\n|a|b|",
                            "layout_right_offset": {
                                "x": -8,
                                "y": -17
                            },
                            "expandState": "collapse"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d4gnowpxyvs0",
                                    "created": 1727398580509,
                                    "text": "4.2 基礎故障處理工具",
                                    "layout_right_offset": {
                                        "x": -8,
                                        "y": 1
                                    },
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4g2zdaxhds0",
                                            "created": 1727340156941,
                                            "text": "4.2.1 jps: 虚拟机进程状况工具",
                                            "note": "jps（JVM Process Status Tool）它的功能也和ps命令类似：可以列出正在运行的虚拟机进\n程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一\nID（LVMID，Local Virtual Machine Identifier）"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4g30876ew00",
                                            "created": 1727340224194,
                                            "text": "4.2.2 jstat：虚拟机统计信息监视工具",
                                            "note": "jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可\n以显示本地或者远程[1]虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据，在没有\nGUI图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工\n具。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4g32kav1p40",
                                            "created": 1727340407266,
                                            "text": "4.2.3　jinfo：Java配置信息工具",
                                            "note": "jinfo（Configuration Info for Java）的作用是实时查看和调整虚拟机各项参数。使用jps命令的-v参\n数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除\n了去找资料外，就只能使用jinfo的-flag选项进行查询了（如果只限于JDK 6或以上版本的话，使用java-\nXX：+PrintFlagsFinal查看参数默认值也是一个很好的选择）。jinfo还可以使用-sysprops选项把虚拟机\n进程的System.getProperties()的内容打印出来。这个命令在JDK 5时期已经随着Linux版的JDK发布，当\n时只提供了信息查询的功能，JDK 6之后，jinfo在Windows和Linux平台都有提供，并且加入了在运行期\n修改部分参数值的能力（可以使用-flag[+|-]name或者-flag name=value在运行期修改一部分运行期可写的\n虚拟机参数值）。在JDK 6中，jinfo对于Windows平台功能仍然有较大限制，只提供了最基本的-flag选\n项。\n\n格式：\njinfo [ option ] pid"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4g35fr2jz40",
                                            "created": 1727340632455,
                                            "text": "4.2.4　jmap：Java内存映像工具",
                                            "note": "jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。如\n果不使用jmap命令，要想获取Java堆转储快照也还有一些比较“暴力”的手段：譬如在第2章中用过的-\nXX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在内存溢出异常出现之后自动生成堆转储\n快照文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快\n照文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“恐吓”一下虚拟机，也能顺利拿到堆转\n储快照。\njmap的作用并不仅仅是为了获取堆转储快照，它还可以查询finalize执行队列、Java堆和方法区的\n详细信息，如空间使用率、当前用的是哪种收集器等。\n和jinfo命令一样，jmap有部分功能在Windows平台下是受限的，除了生成堆转储快照的-dump选项\n和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统中都可以使用之外，其余选项都\n只能在Linux/Solaris中使用。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4g36p5l4mw0",
                                            "created": 1727340731288,
                                            "text": "4.2.5　jhat：虚拟机堆转储快照分析工具",
                                            "note": "JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。\n功能簡陋，建議使用專業dump分析工具，如：Eclipse Memory Analyser"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4g38tj1nwg0",
                                            "created": 1727340897537,
                                            "text": "4.2.6　jstack：Java堆栈跟踪工具",
                                            "note": "jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者\njavacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的\n目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂\n起等，都是导致线程长时间停顿的常见原因。线程出现停顿时通过jstack来查看各个线程的调用堆栈，\n就可以获知没有响应的线程到底在后台做些什么事情，或者等待着什么资源。"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d4gnpeb22vc0",
                                    "created": 1727398618791,
                                    "text": "4.3 可視化故障處理工具",
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4gnq1v3tew0",
                                            "created": 1727398670070,
                                            "text": "4.3.1　JHSDB：基于服务性代理的调试工具",
                                            "note": "JHSDB是一款基于服务性代理（Serviceability Agent，SA）实现的进程外调试工具。服务性代理是\nHotSpot虚拟机中一组用于映射Java虚拟机运行信息的、主要基于Java语言（含少量JNI代码）实现的\nAPI集合"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4gntlwwxnk0",
                                            "created": 1727398948807,
                                            "text": "4.3.2　JConsole：Java监视与管理控制台"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4gnu1cgosg0",
                                            "created": 1727398982399,
                                            "text": "4.3.3　VisualVM：多合-故障处理工具"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4gnz77f1cw0",
                                            "created": 1727399386976,
                                            "text": "4.3.4　Java Mission Control：可持续在线的监控工具"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d4go4vz9o540",
                                    "created": 1727399832723,
                                    "text": "4.4　HotSpot虚拟机插件及工具"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d4go8fbgsm80",
                            "created": 1727400109912,
                            "text": "Chapter 5 調優案例與分析實戰",
                            "expandState": "collapse"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d4gon8w98600",
                                    "created": 1727401271394,
                                    "text": "5.2.1　大内存硬件上的程序部署策略"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4gonb1e3vk0",
                                            "created": 1727401276058,
                                            "text": "1）通过一个单独的Java虚拟机实例来管理大量的Java堆内存"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4gopq59z080",
                                                    "created": 1727401465673,
                                                    "text": "要求",
                                                    "note": "1. 對用戶用户交互性强、对停顿时间敏感、内存又较大的系统，情況允許的話使用shenandoah、ZGC\n2. 若使用Parallel Scavenge/Old收集器，需保證FullGC頻率足夠低，十幾小時乃至1天都沒有一次FullGC,這樣可以通過在閒時通過job觸發FullGC或重啟應用來解決內存問題\n3. 控制FullGC頻率的關鍵在於老年代的相對穩定，避免成批、長時間生存的大對象產生"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4gotpp8b1c0",
                                                    "created": 1727401778160,
                                                    "text": "面臨問題",
                                                    "note": "1. 回收大塊堆內存會導致長時間停頓，G1收集器對該問題有所緩解，Shenandoah和ZGC徹底解決\n2. 大内存必须有64位Java虚拟机的支持，但由于压缩指针、处理器缓存行容量（Cache Line）等因素，64位虚拟机的性能测试结果普遍略低于相同版本的32位虚拟机。\n3. 必须保证应用程序足够稳定，因为这种大型单体应用要是发生了堆内存溢出，几乎无法产生堆转储快照（要产生十几GB乃至更大的快照文件），哪怕成功生成了快照也难以进行分析；如果确实出了问题要进行诊断，可能就必须应用JMC这种能够在生产环境中进行的运维工具。\n4. 相同的程序在64位虚拟机中消耗的内存一般比32位虚拟机要大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的，可以开启（默认即开启）压缩指针功能来缓解"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4gonfygsg80",
                                            "created": 1727401286765,
                                            "text": "2）同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4gozmsr7c00",
                                                    "created": 1727402242027,
                                                    "text": "要求",
                                                    "note": "1. 增加負載均衡器\n2. 若按職責、領域作應用拆分，需考慮狀態保留、熱轉移之類的高可用需求\n3. 若只是為了盡可能利用硬件資源，可考慮使用無Session複製的親合式集群，負載均衡器按規則算法（譬如根据Session ID分配）将一个固定的用户请求永远分配到一个固定的集群节点进行处理即可"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4goxnyb7vk0",
                                                    "created": 1727402087812,
                                                    "text": "面臨問題",
                                                    "note": "1. 节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致I/O异常。\n2. 很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点的连接池已经满了，而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI来解决，但这个方案有一定复杂性并且可能带来额外的性能代价。\n3. 如果使用32位Java虚拟机作为集群节点的话，各个节点仍然不可避免地受到32位的内存限制，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆最多一般只能开到1.5GB。在某些Linux或UNIX系统（如Solaris）中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB（2的32次幂）内存的限制。\n4. 大量使用本地缓存（如大量使用HashMap作为K/V缓存）的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时候可以考虑把本地缓存改为集中式缓存。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d4gptm4hjhc0",
                                    "created": 1727404591485,
                                    "text": "5.2.3　堆外内存导致的溢出错误"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4gq70sav1c0",
                                            "created": 1727405642134,
                                            "text": "注意",
                                            "note": "1. 堆外內存溢出不響應-XX：+HeapDumpOnOutOfMemoryError參數\n2. 堆外內存空間不足沒有通知，只能等待老年代滿後FullGC出現，順便清理直接內存的廢棄對象\n3. 可以在程式拋出內存溢出異常時，捕獲異常，再調用System.gc()觸發FullGC，以此解決直接內存溢出問題（虛擬機不能啟用-XX：+DisableExplicitGC）"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d4j7bh71qds0",
                                    "created": 1727657070093,
                                    "text": "5.2.4  外部命令导致系统缓慢",
                                    "note": "注意程式調用系統命令時的資源消耗"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d4j7ctf592w0",
                                    "created": 1727657175068,
                                    "text": "5.2.5　服务器虚拟机进程崩溃",
                                    "note": "避免服務同時接受大規模的請求數量，若服務無法接受大規模請求量，考慮改為消息隊列模式"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d4j7e020gyw0",
                                    "created": 1727657267875,
                                    "text": "5.2.6　不恰当数据结构导致内存占用过大",
                                    "note": "注意大對象存儲的空間佔用，提高對象空間效率"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d4j7h2v10i80",
                                    "created": 1727657509076,
                                    "text": "5.2.7　由Windows虚拟内存导致的长时间停顿",
                                    "note": "GUI桌面程序避免因為虛擬內存而導致程序性能問題，可以加入参数“-\nDsun.awt.keepWorkingSetOnMinimize=true”来避免程序閒時被交換到虛擬內存"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d4j7mzxrc5c0",
                                    "created": 1727657972896,
                                    "text": "5.2.8　由安全点导致长时间停顿",
                                    "note": "参数-XX：\n+PrintSafepointStatistics和-XX：PrintSafepointStatisticsCount=1查看安全点日志\n\n添加-XX：\n+SafepointTimeout和-XX：SafepointTimeoutDelay=2000两个参数，让虚拟机在等到线程进入安全点的\n时间超过2000毫秒时就认定为超时，这样就会输出导致问题的线程名称\n\n雖然循環會放置安全點，但若循環的索引值為int類型，這種循環被稱為可數循環，虛擬機會認為該循環不會執行很長時間，故不會設置安全點。\n若使用long或更大範圍的數據類型作為索引值（不可數循環），虛擬機則會放置安全點\n\n根據上面的虛擬機安全點設置規則，在循環內程序執行時間很長，循環的索引值應考慮long類型，避免使用int類型導致虛擬機不設置安全點，進而導致其它線程等待該線程完成長時間的循環"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "d4j9fxcagio0",
                    "created": 1727663060915,
                    "text": "虛擬機執行子系統",
                    "layout_mind_offset": {
                        "x": -67,
                        "y": 45
                    }
                },
                "children": [
                    {
                        "data": {
                            "id": "d4j9bx64peo0",
                            "created": 1727662747085,
                            "text": "Chapter6 類文件結構",
                            "layout_mind_offset": {
                                "x": -91,
                                "y": 55
                            },
                            "note": "曾记得在第一堂计算机程序课上老师就讲过：“计算机只认识0和1，所以我们写的程序需要被编译\n器翻译成由0和1构成的二进制格式才能被计算机执行。”十多年过去了，今天的计算机仍然只能识别0\n和1，但由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，\n把我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语\n言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d4j9c5h9mxs0",
                                    "created": 1727662765173,
                                    "text": "6.3 Class類文件結構"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4jabzvdmeo0",
                                            "created": 1727665574076,
                                            "text": "6.3.1 魔數與Class文件的版本",
                                            "note": "Class文件開始4個字節為：CAFEBABE\n緊接著為2字節的次版本號和2字節的主版本號"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "d2i222zx0ig0",
                    "created": 1720228351523,
                    "text": "虛擬機性能相關參數",
                    "layout_mind_offset": {
                        "x": 24,
                        "y": -90
                    },
                    "note": "1. 本地線程分配緩衝",
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "id": "d2i24vfkhlc0",
                            "created": 1720228570147,
                            "text": "本地線程分配緩衝",
                            "note": "本地線程分配緩衝（Thread Local Allocation Buffer,TLAB）\n線程需要分配內存時，優先在各自線程的分配緩衝區中分配，只有本地緩衝區用完了，分配新的緩存區時才需要同步鎖定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d4azu6vig080",
                            "created": 1726823488014,
                            "text": "卡錶更新增加判斷",
                            "note": "在JDK 7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启\n卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损\n耗，是否打开要根据应用实际运行情况来进行测试权衡。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d4g2iokkagw0",
                            "created": 1727338849277,
                            "text": "晉升老年代閾值",
                            "note": "-XX：MaxTenuringThreshold=15"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d4gqtciz5z40",
                            "created": 1727407391703,
                            "text": "直接晉升老年代閾值",
                            "note": "-XX:PretenureSizeThreshold=对象大小(单位：byte)，只对Serial和ParNew两款收集器有效"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "d4e4qbc9sv40",
                    "created": 1727141969697,
                    "text": "虛擬機內存分析參數",
                    "layout_mind_offset": {
                        "x": 44,
                        "y": 53
                    },
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "id": "d4e4r1s766g0",
                            "created": 1727142027257,
                            "text": "本地內存（直接內存）分析",
                            "note": "NMT的全称是Native Memory Tracker ，是一个本地内存跟踪工具。\n常用来分析JVM的内存使用情况。NMT功能默认关闭，可以通过以下方式开启:\n\n\n-XX:NativeMemoryTracking=[off | summary | detail]\n\n\n開啟後通過jcmd查看內存佔用：\njcmd 17667  VM.native_memory detail scale=MB >temp.txt\n\njcmd 17667 VM.native_memory baseline --生成快照\njcmd 13527 VM.native_memory scale=MB detail.diff   --包含具体的内存分配信息\njcmd 13527 VM.native_memory scale=MB summary.diff  --只包含内存概要信息"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d4e4sfo9g2o0",
                            "created": 1727142135858,
                            "text": "JVM退出時打印內存使用狀況",
                            "note": "-XX:+UnlockDiagnosticVMOptions -XX:+PrintNMTStatistics"
                        },
                        "children": []
                    }
                ]
            }
        ]
    },
    "template": "default",
    "theme": "fresh-blue",
    "version": "1.4.43"
}