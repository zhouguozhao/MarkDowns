{
    "root": {
        "data": {
            "id": "d2gk685jog80",
            "created": 1720076336269,
            "text": "JVM"
        },
        "children": [
            {
                "data": {
                    "id": "d2gk8gqqoyo0",
                    "created": 1720076511693,
                    "text": "自動內存管理"
                },
                "children": [
                    {
                        "data": {
                            "id": "d2gkg028cb40",
                            "created": 1720077102296,
                            "text": "Chapter2 Java內存區域與內存溢出異常",
                            "expandState": "collapse"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d2gkiegtjl40",
                                    "created": 1720077290381,
                                    "text": "2.1 概述"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d2gkiimqanc0",
                                    "created": 1720077299445,
                                    "text": "2.2 運行時數據區域",
                                    "expandState": "expand"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d2gkrqr9o4g0",
                                            "created": 1720078022412,
                                            "text": "2.1.1 程序計數器",
                                            "note": "1. 線程私有\n2. 字節碼解釋器通過改變這個計數器的值來選取下一條需要執行的字節碼指令\n3. 分支、循環、跳轉、異常處理、線程恢復等需要依賴這個計數器完成\n4. 執行java方法時，計數器的值是正在執行指令的地址，執行native方法時，計數器的值為Undefined\n5. 此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2glwm5mz6o0",
                                            "created": 1720081225327,
                                            "text": "2.2.2 Java虛擬機棧",
                                            "note": "1. 線程私有，生命週期與線程相同\n2. 虛擬機棧用於存儲被執行的方法，每個方法被執行，就會在棧中創建一個棧幀，方法執行完成，對應的棧幀會出棧\n3. 棧幀包含：局部變量表、操作數棧、動態連接、方法出口等信息\n4. 局部變量表存放編譯期可知的基本數據類型（boolean、byte、char、short、int、float、long、double）、對象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）\n5. 局部變量表的存儲空間以變量槽（Slot）來表示，64位長度的long和double佔2個變量槽，其餘數據類型只佔1個，局部變量表所需空間大小在編譯期確定，並且運行期不會改變，此處的大小為變量槽個數，具體一個變量槽多大由虛擬機實現決定\n6. 線程請求棧深大於虛擬機允許的棧深，則拋出StackOverflowError異常；若虛擬機棧可擴容，當棧擴展時無法申請到足夠內存則拋出OutOfMemoryError異常（HotSpot虛擬機的棧容量不可動態擴展，但若申請時就失敗，仍有可能拋出OOM）"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gm7qpu6e80",
                                            "created": 1720082097262,
                                            "text": "2.2.3 本地方法棧",
                                            "note": "1. 虛擬機棧為java方法服務，本地方法棧為虛擬機使用到的本地方法服務\n2. HotSpot虛擬機將虛擬機棧和本地方法棧合二為一\n3. 線程私有"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gmebmd69s0",
                                            "created": 1720082612949,
                                            "text": "2.2.4 Java堆",
                                            "note": "1. Java堆用於存儲對象\n2. 堆中可劃分多個線程私有的分配緩衝區（Thread Local Allocation Buffer，TLAB），以提升對象分配效率\n3. 堆物理上可不連續，邏輯上應該連續（大對象出於簡單和存儲高效考慮，可能會要求連續的存儲空間，如數組）\n4. java堆可擴展（-Xmx、-Xms設定）\n5. 線程共享\n6. 如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gmm0td00w0",
                                            "created": 1720083216341,
                                            "text": "2.2.5 方法區",
                                            "note": "1. 線程共享\n2. jdk8開始啟用永久代，改為使用元空間（Metaspace）實現方法區\n3. jdk8開始方法區在本地內存中\n4. 方法區的內存回收較為困難，主要是常量池的回收及類型的卸載，回收效果難令人滿意\n5. 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据\n6. 如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gmyibnihs0",
                                            "created": 1720084194822,
                                            "text": "2.2.6 運行時常量池",
                                            "note": "1. 運行時常量池是方法區的一部分\n2. class文件包含：類的版本、字段、方法、接口、常量池表\n3. 常量池表用於存放編譯期生成的各種字面量和符號引用，在類加載後存放到方法區的運行時常量池\n4. 運行期也可以將新的常量放入運行時常量池，即使沒有預置在class文件中，如String.intern()\n5. 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gn6a6srp40",
                                            "created": 1720084804028,
                                            "text": "2.2.7 直接內存",
                                            "note": "1. 直接內存不是虛擬機運行時數據區的一部分，也不是Java虛擬機規範中定義的內存區域\n2. JDK1.4新增的NIO可以使用Native函數庫直接分配對外內存，再通過堆裡的DirectByteBuffer對象作為這塊內存的引用進行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n3. 直接內存不受堆大小控制"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d2gn961rvm80",
                                    "created": 1720085030109,
                                    "text": "2.3 HotSpot虛擬機對象探秘",
                                    "layout_right_offset": {
                                        "x": -16,
                                        "y": -1
                                    }
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d2gnh0jzu080",
                                            "created": 1720085645063,
                                            "text": "2.3.1 對象的創建",
                                            "note": "1. 虛擬機接受到new指令\n2. 檢查指令參數是否能在常量池定位一個符號引用\n3. 檢查該符號引用代表的類是否已被加載、解析初始化過，沒有則執行類加載\n4. 類加載通過後開始為新生對象分配內存，所需內存大小在類加載完成即可確定。內存分配可使用指針碰撞（Bump The Pointer）或空閒列表（Free List）的方式\n5. 除分配內存外，還需要考慮並發問題：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。\n解決方式：\n1. CAS+失敗重試（虛擬機採用這種方式）\n2. 把內存分配根據線程劃分在不同的內存空間中，線程緩衝區使用完了再同步（TLAB）\n\n6. 內存分配完成後，便要分配到的內存（不包括對相投）初始化為零值，，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。保證了java代碼中實例字段即使不賦初值也可使用\n\n7. 對象頭設定，如：類信息、對象哈希碼（調用Object::hashCode()才計算）、GC分代年齡等\n\n8. 執行類的構造函數\n\n\n\n\n",
                                            "layout_right_offset": {
                                                "x": 7,
                                                "y": 1.5
                                            }
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d2i2vs5xgao0",
                                                    "created": 1720230678866,
                                                    "text": "內存分配方式",
                                                    "note": "1. 指針碰撞（Bump The Pointer)\n> 針對規整的內存，所有使用過的內存放在一邊，空閒的內存在另一邊，中間放一個指針作為分界點指示器，此時內存分配就是指針向空閒空間方向移動對象大小的距離\n\n2. 空閒列表（Free List）\n> 針對不規整內存（已使用和空閒內存交錯在一起），虛擬機維護一個空閒列表，記錄哪些內存塊可用，分配時從列表中找出一塊足夠大的空間劃分給對象實例，並更新列表記錄\n\n選擇指針碰撞還是空閒列表取決於java堆是否規整。java堆是否規整由所採用的垃圾收集器是否帶有空間壓縮能力決定。\n如Serial、ParNew有壓縮整理過程，系統採用的分配算法是指針碰撞，簡單高效\nCMS收集器基於清除算法，理論上只能採用較為複雜的空閒列表方式分配內存\n\n强调“理论上”是因为在CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作Linear\nAllocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指\n针碰撞方式来分配。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d2i3uez011s0",
                                                    "created": 1720233392895,
                                                    "text": "內存分配並發問題解決"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d2i3vkf36k00",
                                                            "created": 1720233483116,
                                                            "text": "線程分配緩衝",
                                                            "note": "本地線程分配緩衝（Thread Local Allocation Buffer,TLAB）\n線程需要分配內存時，優先在各自線程的分配緩衝區中分配，只有本地緩衝區用完了，分配新的緩存區時才需要同步鎖定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d2i3vqcgmxs0",
                                                            "created": 1720233496018,
                                                            "text": "CAS+失敗重試",
                                                            "note": "什么是CAS（CAS屬於樂觀鎖）？\nCAS是一种非阻塞式并发控制技术，它主要用于解决多个线程同时访问同一个共享资源时可能出现的竞争条件问题。为了保证数据的一致性和正确性，我们通常需要采取同步机制来对共享资源进行加锁。但是，传统的锁机制在高并发场景下会带来严重的性能问题，因为所有线程都需要等待锁的释放才能进行操作，这就会导致大量线程的阻塞和唤醒，进而降低了系统的并发性能。\n为了解决这个问题，CAS应运而生。它是一种无锁的同步机制，可以在不使用锁的情况下实现数据的同步和并发控制。CAS的核心思想是：在执行操作之前，先比较当前内存中的值是否等于期望值，如果相等，则执行修改操作；如果不相等，则不执行修改操作，继续进行比较，直到内存中的值与期望值相等为止。这个过程中不会出现线程的阻塞和唤醒，因此可以提高系统的并发性能。\n\n* 开销问题\n>在 CAS 期间，线程是不会休息的，线程如果长时间无法提交，内部就一直在进行自旋，这样就会产生比较大的内存开销\nCAS 只能够保证一个共享变量的原子操作\nCAS 只能保证对一个内存地址进行原子操作，所以说使用范围会有一定限制\n例如：如果在执行 a+1 的下面加上，b+1，c +1，这种情况就会出现问题，这种时候反而使用 Syn 比较方便\n多個變量的院子操作可考慮Java的AtomicReference"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4469byk27k0",
                                            "created": 1726130681507,
                                            "text": "2.3.2 對象的內存佈局"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4469kyefq80",
                                                    "created": 1726130701089,
                                                    "text": "對象頭"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d446b13vp140",
                                                            "created": 1726130814613,
                                                            "text": "MarkWord",
                                                            "note": "MarkWord用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特。\nMark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根\n据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态\n下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年\n龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标\n记、可偏向）下对象的存储内容參考MarkDown2.3.2內容。"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d446b1evkpc0",
                                                            "created": 1726130815277,
                                                            "text": "類型指針",
                                                            "note": "指向類型元數據，用以確定對象的類型信息。（不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话\n说，查找对象的元数据信息并不一定要经过对象本身）\n如果該對象是java數組，則對象頭還需存放數組的長度信息（因為如果數組的長度是不定的，無法通過元數據推斷數組大小）"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            },
                                            {
                                                "data": {
                                                    "id": "d4469oqtg4w0",
                                                    "created": 1726130709337,
                                                    "text": "實例數據",
                                                    "note": "該部分是對象真正存儲的有效信息，包含代碼中定義的各種類型的字段，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。\n存储顺序会\n受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。\nHotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary\nObject Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存\n放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的\n+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空\n隙之中，以节省出一点点空间。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4469p1nzeo0",
                                                    "created": 1726130709993,
                                                    "text": "對齊填充",
                                                    "note": "对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作\n用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是\n任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者\n2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d446w5m8u000",
                                            "created": 1726132470078,
                                            "text": "2.3.3 對象的訪問定位",
                                            "note": "1. 句柄訪問的優勢在於穩定的句柄地址，即使對象被移動，也只需要修改句柄池中實例數據的指針\n2. 直接訪問的優勢在於速度更快，因為節省了一次對象定位的時間\nHotSpot主要使用直接訪問的方式進行對象訪問"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4471l61g9s0",
                                                    "created": 1726132895747,
                                                    "text": "句柄訪問",
                                                    "note": "如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就\n是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息其结构參考MarkDown。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4471lhgwp40",
                                                    "created": 1726132896438,
                                                    "text": "直接訪問",
                                                    "note": "如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关\n信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问\n的开销，其结构參考MarkDown。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d4475b2gdc00",
                            "created": 1726133187219,
                            "text": "Chapter3 垃圾收集器與內存分配策略",
                            "note": "·哪些内存需要回收？\n·什么时候回收？\n·如何回收？"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d4476tkmt680",
                                    "created": 1726133305865,
                                    "text": "3.2 對象存活算法",
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4478pfin3c0",
                                            "created": 1726133453576,
                                            "text": "3.2.1 引用計數法",
                                            "note": "在对象中添加一个引用计数器，每当有一个地方\n引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可\n能再被使用的。\n缺點：\n这个看似简单\n的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数\n就很难解决对象之间相互循环引用的问题。举个简单的例子，请看代码清单3-1中的testGC()方法：对象objA和objB都有字段instance，赋值令\nobjA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已\n经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也\n就无法回收它们。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d447a11t29k0",
                                            "created": 1726133557233,
                                            "text": "3.2.2 可達性分析算法",
                                            "note": "当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是\n通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过\n一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过\n程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，\n或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d44u4w0rmtc0",
                                                    "created": 1726198039993,
                                                    "text": "固定GC Roots",
                                                    "note": "·在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。\n·在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。\n·在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。\n·在本地方法栈中JNI（即通常所说Native方法）引用的对象。\n·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。\n·所有被同步锁（synchronized关键字）持有的对象。\n·反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44u7zq5bxc0",
                                                    "created": 1726198283151,
                                                    "text": "額外GC Roots",
                                                    "note": "除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不\n同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。譬如后文将会提到的分代收集\n和局部回收（Partial GC），如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生\n代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不\n可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引\n用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确\n性。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d44ub10mkg00",
                                            "created": 1726198521054,
                                            "text": "3.2.3 引用分類",
                                            "note": "无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可\n达，判定对象是否存活都和“引用”离不开关系。在JDK 1.2版之前，Java里面的引用是很传统的定义：\n如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表\n某块内存、某个对象的引用。这种定义并没有什么不对，只是现在看来有些过于狭隘了，一个对象在\n这种定义下只有“被引用”或者“未被引用”两种状态，对于描述一些“食之无味，弃之可惜”的对象就显\n得无能为力。譬如我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空\n间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的应\n用场景。\n在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软\n引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强\n度依次逐渐减弱。"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d44ubpq1j6o0",
                                                    "created": 1726198574833,
                                                    "text": "強引用",
                                                    "note": "·强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回\n收掉被引用的对象。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44ubpzg0rk0",
                                                    "created": 1726198575402,
                                                    "text": "軟引用",
                                                    "note": "·软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内\n存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，\n才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44ubq55dbs0",
                                                    "created": 1726198575747,
                                                    "text": "弱引用",
                                                    "note": "·弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只\n能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只\n被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44ubqanfl40",
                                                    "created": 1726198576079,
                                                    "text": "虛引用",
                                                    "note": "·虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的\n存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚\n引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供\n了PhantomReference类来实现虚引用。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d44wznrvle80",
                                            "created": 1726206093550,
                                            "text": "3.2.4 GC對象回收流程"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d44x0cvwo9k0",
                                                    "created": 1726206148214,
                                                    "text": "1. 判定對象不可達",
                                                    "note": "可达性分析算法中判定为不可达的对象"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44x0hfb41k0",
                                                    "created": 1726206158094,
                                                    "text": "2. 第一次標記",
                                                    "note": "如果对象在进行可达性分析后发现没\n有与GC Roots相连接的引用链，那它将会被第一次标记"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44x3bjnyr40",
                                                    "created": 1726206380389,
                                                    "text": "3. 篩選是否需要執行finalize()",
                                                    "note": "随后进行一次筛选，筛选的条件是此对象是\n否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用\n过，那么虚拟机将这两种情况都视为“没有必要执行”。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44x5wl8y680",
                                                    "created": 1726206582926,
                                                    "text": "4. 需要執行finalize()對象放入F-Queue",
                                                    "note": "如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的\n队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()\n方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。\n这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导\n致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44x2ckoe0o0",
                                                    "created": 1726206304263,
                                                    "text": "5. 執行對象的finalize()",
                                                    "note": "对象的finalize()方法都只会被系统自动调用一次，如果对象面临\n下一次回收，它的finalize()方法不会被再次执行;\n还有一点需要特别说明，上面关于对象死亡时finalize()方法的描述可能带点悲情的艺术加工，笔\n者并不鼓励大家使用这个方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它并不能等同\n于C和C++语言中的析构函数，而是Java刚诞生时为了使传统C、C++程序员更容易接受Java所做出的一\n项妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为\n不推荐使用的语法。有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize()\n方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、\n更及时，所以笔者建议大家完全可以忘掉Java语言里面的这个方法。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d44x0nj73740",
                                                    "created": 1726206171390,
                                                    "text": "6. 對F-Queue中的對象二次標記",
                                                    "note": "finalize()方法是对\n象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对\n象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己\n（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集\n合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d44ytwz3x0g0",
                                            "created": 1726211285613,
                                            "text": "3.2.5 回收方法区",
                                            "note": "有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚\n拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整\n实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集\n的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常\n可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回\n收成果往往远低于此。\n方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。回收废弃常量与回收\nJava堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池\n中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用\n常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且\n垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接\n口）、方法、字段的符号引用也与此类似。"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4519rhfxy80",
                                                    "created": 1726218169708,
                                                    "text": "廢棄的常量",
                                                    "note": "举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池\n中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用\n常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且\n垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接\n口）、方法、字段的符号引用也与此类似。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4519rt6pzk0",
                                                    "created": 1726218170418,
                                                    "text": "不再被使用的類",
                                                    "note": "判定一个类型是否属于“不再被使用的类”的条件，需要同时满足下面三个条件：\n* 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。\n* 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如\nOSGi、JSP的重加载等，否则通常是很难达成的。\n* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方\n法。\nJava虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是\n和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-\nXnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClass-Loading、-XX：\n+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在\nProduct版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版[1]的虚拟机支持。\n在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载\n器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压\n力。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d45og1s14ag0",
                                    "created": 1726283547829,
                                    "text": "3.3 垃圾收集算法",
                                    "note": "从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference\nCounting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接\n垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不\n把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。",
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d45oi282kjc0",
                                            "created": 1726283705527,
                                            "text": "3.3.1 分代收集理論"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d45oubl8vio0",
                                                    "created": 1726284666285,
                                                    "text": "1. 弱分代假說",
                                                    "note": "**绝大多数对象都是朝生夕灭的**\n"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d45ouf6n3jk0",
                                                    "created": 1726284674109,
                                                    "text": "2. 強分代假說",
                                                    "note": "**熬过越多次垃圾收集过程的对象就越难以消亡**\n強分代假說和弱分代假說奠定了多數立即收集器的設計原則：\n：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。\n朝生夕滅的對象集中放到一起，以較高頻率回收；難以消亡的對象放到一起，以較低頻率回收，这就同时兼顾了垃圾收集的时间开销和内存的空间有\n效利用。\n\njava堆劃分不同區域，引出了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分，因此針對不同區域的回收發展出了了“标记-复制算法”“标记-清除算\n法”“标记-整理算法”等针对性的垃圾收集算法"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d45oufua0gg0",
                                                    "created": 1726284675538,
                                                    "text": "3. 跨代引用假說",
                                                    "note": "**跨代引用相对于同代引用来说仅占极少数**\n跨代引用：新生代中的对象是完全有可\n能被老年代所引用的\n为了找出新生代中的存活对象，不得不在固定的GC Roots之外，再额外遍历整\n个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样[3]。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，引申出了跨代引用假說：**跨代引用相对于同代引用来说仅占极少数**\n依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录\n每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称\n为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会\n存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC\nRoots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数\n据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d45p2y4t7hk0",
                                                    "created": 1726285342270,
                                                    "text": "不同GC類型定義",
                                                    "note": "·部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：\n■新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。\n■老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单\n独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，\n读者需按上下文区分到底是指老年代的收集还是整堆收集。\n■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收\n集器会有这种行为。\n·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d45p3vupfqw0",
                                            "created": 1726285415670,
                                            "text": "3.3.2 標記-清除算法",
                                            "note": "如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回\n收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回\n收所有未被标记的对象。\n優點：\n1. 沒有後續的複製或整理動作，速度較快\n\n缺點：\n1. 執行效率不穩定，若java堆中有大量需要被回收的對象，這是必須進行大量標記和清除動作，导致标记和清除两个过\n程的执行效率都随对象数量增长而降低\n2. 內存空間碎片化問題：标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d45p91k468w0",
                                            "created": 1726285819911,
                                            "text": "3.3.3 標記-複製算法",
                                            "note": "为了解决标记-清除算法面对大量可回收对象时执行效率低\n的问题，1969年Fenichel提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用\n内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着\n的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存\n活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复\n制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有\n空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷\n也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一\n点\n现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，IBM公司曾有一项专门研\n究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集。因此\n并不需要按照1∶1的比例来划分新生代的内存空间。\n```\n“Appel式回收”\n針對對象朝生夕滅的特點，在1989年，Andrew Appel提出了一种更优化的半区复制分代策略：具体做法是把新生代分为一块较大的Eden空间和两块较小的\nSurvivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍\n然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空\n间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1\n```"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d45pev9f0v40",
                                                    "created": 1726286276388,
                                                    "text": "內存分配擔保",
                                                    "note": "在Appel式回收中，可能發生suvivor空間不足以存放一次Minor GC剩餘對象時，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d45pgrwc4h40",
                                            "created": 1726286425795,
                                            "text": "3.3.4 標記-整理算法",
                                            "note": "针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整\n理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可\n回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内\n存，\n标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的；\n移動存活對象會涉及對象引用的變更，這種操作必須全程暫停用戶應用進程才能進行（Stop The World）\n像標記-清除算法若不移動和整理存活對象，則空間碎片化問題稚嫩惡搞依賴更複雜的內存分配器和內存訪問器來解決\n但總的來說，移動對象對程序的吞吐量還是有益的（沒有空間碎片化問題，可順序分配對象空間）\nHotSpot虚拟机里面关注吞吐量的Parallel\nScavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从\n侧面印证这点。\n另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚\n拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经\n大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标\n记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。\n\n老年代對象存活概率較高，故老年代一般不能直接使用標記-複製算法"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d45rod3qchs0",
                                    "created": 1726292662724,
                                    "text": "3.4 HotSpot的算法細節實現",
                                    "expandState": "collapse"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d45sayojbq00",
                                            "created": 1726294433706,
                                            "text": "3.4.1 根節點枚舉",
                                            "note": "固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如\n栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应\n用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检\n查以这里为起源的引用肯定得消耗不少时间。\n\n迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。因為根節點枚舉需要在一個一致性快照中執行才有意義，若一邊枚舉一邊引用不停變換，那麼枚舉是沒有意義的。即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。\n為避免一個不漏的從方法區查找GC Roots，HostSpot通過維護一組名為OoPMap（Ordinary Object Pointer，OOP）的數據結構來減少查找GC Roots的時間。。一旦类加载动作完成的时候，\nHotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（见第11章）过程中，也\n会在特定的位置记录下栈里和寄存器里哪些位置是引用，並記錄到OopMap中。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d45seunpjgw0",
                                            "created": 1726294738405,
                                            "text": "3.4.2 安全點"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4aync0evqo0",
                                                    "created": 1726820129535,
                                                    "text": "可以產生安全點的指令"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4aynl716800",
                                                    "created": 1726820149526,
                                                    "text": "中斷方式"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4aynq1jbfc0",
                                                    "created": 1726820160078,
                                                    "text": "主動式中斷性能"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4aymu4x9ps0",
                                            "created": 1726820090626,
                                            "text": "3.4.3 安全區域"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4ayojjoqbk0",
                                            "created": 1726820224302,
                                            "text": "3.4.4 記憶集與卡錶"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4aypluce600",
                                                    "created": 1726820307664,
                                                    "text": "概念及作用"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4ayr4d1za80",
                                                    "created": 1726820426342,
                                                    "text": "記憶集的精度"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4ayr9lbv5c0",
                                                    "created": 1726820437726,
                                                    "text": "卡錶"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4az4a9r8ag0",
                                            "created": 1726821457937,
                                            "text": "3.4.5 寫屏障"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4azvbw5rkw0",
                                                    "created": 1726823577301,
                                                    "text": "概念"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4azvfwd6740",
                                                    "created": 1726823586021,
                                                    "text": "卡錶何時變髒、誰來變髒"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4azw32oacg0",
                                                    "created": 1726823636468,
                                                    "text": "偽共享問題"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4b09eqpau80",
                                            "created": 1726824680600,
                                            "text": "3.4.6 並發的可達性分析"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4b3xhb0wrk0",
                                                    "created": 1726835030252,
                                                    "text": "用戶線程與GC線程並發產生的問題"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4b3xtyf2js0",
                                                    "created": 1726835057788,
                                                    "text": "引用變化導致對象消失問題"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4b3y8bloy00",
                                                    "created": 1726835089060,
                                                    "text": "對象消失條件"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4b3ydjmb4w0",
                                                    "created": 1726835100428,
                                                    "text": "解決對象消失方法"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d4b3yi4q9xs0",
                                                            "created": 1726835110412,
                                                            "text": "增量更新"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d4b3yl650o00",
                                                            "created": 1726835117028,
                                                            "text": "原始快照"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d4blx6ak7o80",
                                    "created": 1726885786257,
                                    "text": "3.5 經典垃圾收集器"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d4blxexaq140",
                                            "created": 1726885805046,
                                            "text": "3.5.1 Serial收集器",
                                            "note": "新生代使用標記-複製算法\n老年代使用標記-整理算法\n\n標記階段需暫停用戶線程"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4blyt91ebs0",
                                            "created": 1726885914595,
                                            "text": "3.5.2 ParNew收集器",
                                            "note": "Serial收集器的改進版本\n新生代GC線程改為多線程並行\njdk9之後只能與CMS搭配使用（jdk9 CMS被標記為棄用）"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4bm4jwgu600",
                                            "created": 1726886364429,
                                            "text": "3.5.3 Parallel Scavenge收集器",
                                            "note": "\n\n\n"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d4bm7e65afc0",
                                                    "created": 1726886587046,
                                                    "text": "目標",
                                                    "note": "目標：達到一個可控制的吞吐量"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d4bm7hjt6dk0",
                                                    "created": 1726886594403,
                                                    "text": "重要參數",
                                                    "note": "Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间\n的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。\n\n\n\nParallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得我们关注。这是一\n个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区\n的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数\n了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时\n间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）[1]。如果读\n者对于收集器运作不太了解，手工优化存在困难的话，使用Parallel Scavenge收集器配合自适应调节策\n略，把内存管理的调优任务交给虚拟机去完成也许是一个很不错的选择。只需要把基本的内存数据设\n置好（如-Xmx设置最大堆），然后使用-XX：MaxGCPauseMillis参数（更关注最大停顿时间）或-\nXX：GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就\n由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d4bm97mlm3k0",
                                            "created": 1726886729532,
                                            "text": "3.5.4 Serial Old收集器",
                                            "note": "Serial收集器的老年代版本\n標記階段阻塞用戶線程\n\n它也可能有两种用\n途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，另外一种就是作为CMS\n收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4bmbxmvm000",
                                            "created": 1726886942874,
                                            "text": "3.5.5 Parralel Old收集器",
                                            "note": "Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实\n现。\n\nParallel Scavenge加Parallel Old收集器為吞吐量優先組合\n在注重\n吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑；"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d4bmdeejvjk0",
                                            "created": 1726887057740,
                                            "text": "3.5.6 CMS收集器"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "d2i222zx0ig0",
                    "created": 1720228351523,
                    "text": "虛擬機性能相關參數",
                    "layout_mind_offset": {
                        "x": 28,
                        "y": 0
                    },
                    "note": "1. 本地線程分配緩衝",
                    "expandState": "expand"
                },
                "children": [
                    {
                        "data": {
                            "id": "d2i24vfkhlc0",
                            "created": 1720228570147,
                            "text": "本地線程分配緩衝",
                            "note": "本地線程分配緩衝（Thread Local Allocation Buffer,TLAB）\n線程需要分配內存時，優先在各自線程的分配緩衝區中分配，只有本地緩衝區用完了，分配新的緩存區時才需要同步鎖定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d4azu6vig080",
                            "created": 1726823488014,
                            "text": "卡錶更新增加判斷",
                            "note": "在JDK 7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启\n卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损\n耗，是否打开要根据应用实际运行情况来进行测试权衡。"
                        },
                        "children": []
                    }
                ]
            }
        ]
    },
    "template": "default",
    "theme": "fresh-blue",
    "version": "1.4.43"
}