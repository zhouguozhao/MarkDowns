{
    "root": {
        "data": {
            "id": "d2gk685jog80",
            "created": 1720076336269,
            "text": "JVM"
        },
        "children": [
            {
                "data": {
                    "id": "d2gk8gqqoyo0",
                    "created": 1720076511693,
                    "text": "自動內存管理"
                },
                "children": [
                    {
                        "data": {
                            "id": "d2gkg028cb40",
                            "created": 1720077102296,
                            "text": "Chapter2 Java內存區域與內存溢出異常"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d2gkiegtjl40",
                                    "created": 1720077290381,
                                    "text": "2.1 概述"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d2gkiimqanc0",
                                    "created": 1720077299445,
                                    "text": "2.2 運行時數據區域",
                                    "expandState": "expand"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d2gkrqr9o4g0",
                                            "created": 1720078022412,
                                            "text": "2.1.1 程序計數器",
                                            "note": "1. 線程私有\n2. 字節碼解釋器通過改變這個計數器的值來選取下一條需要執行的字節碼指令\n3. 分支、循環、跳轉、異常處理、線程恢復等需要依賴這個計數器完成\n4. 執行java方法時，計數器的值是正在執行指令的地址，執行native方法時，計數器的值為Undefined\n5. 此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2glwm5mz6o0",
                                            "created": 1720081225327,
                                            "text": "2.2.2 Java虛擬機棧",
                                            "note": "1. 線程私有，生命週期與線程相同\n2. 虛擬機棧用於存儲被執行的方法，每個方法被執行，就會在棧中創建一個棧幀，方法執行完成，對應的棧幀會出棧\n3. 棧幀包含：局部變量表、操作數棧、動態連接、方法出口等信息\n4. 局部變量表存放編譯期可知的基本數據類型（boolean、byte、char、short、int、float、long、double）、對象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）\n5. 局部變量表的存儲空間以變量槽（Slot）來表示，64位長度的long和double佔2個變量槽，其餘數據類型只佔1個，局部變量表所需空間大小在編譯期確定，並且運行期不會改變，此處的大小為變量槽個數，具體一個變量槽多大由虛擬機實現決定\n6. 線程請求棧深大於虛擬機允許的棧深，則拋出StackOverflowError異常；若虛擬機棧可擴容，當棧擴展時無法申請到足夠內存則拋出OutOfMemoryError異常（HotSpot虛擬機的棧容量不可動態擴展，但若申請時就失敗，仍有可能拋出OOM）"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gm7qpu6e80",
                                            "created": 1720082097262,
                                            "text": "2.2.3 本地方法棧",
                                            "note": "1. 虛擬機棧為java方法服務，本地方法棧為虛擬機使用到的本地方法服務\n2. HotSpot虛擬機將虛擬機棧和本地方法棧合二為一\n3. 線程私有"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gmebmd69s0",
                                            "created": 1720082612949,
                                            "text": "2.2.4 Java堆",
                                            "note": "1. Java堆用於存儲對象\n2. 堆中可劃分多個線程私有的分配緩衝區（Thread Local Allocation Buffer，TLAB），以提升對象分配效率\n3. 堆物理上可不連續，邏輯上應該連續（大對象出於簡單和存儲高效考慮，可能會要求連續的存儲空間，如數組）\n4. java堆可擴展（-Xmx、-Xms設定）\n5. 線程共享\n6. 如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gmm0td00w0",
                                            "created": 1720083216341,
                                            "text": "2.2.5 方法區",
                                            "note": "1. 線程共享\n2. jdk8開始啟用永久代，改為使用元空間（Metaspace）實現方法區\n3. jdk8開始方法區在本地內存中\n4. 方法區的內存回收較為困難，主要是常量池的回收及類型的卸載，回收效果難令人滿意\n5. 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据\n6. 如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gmyibnihs0",
                                            "created": 1720084194822,
                                            "text": "2.2.6 運行時常量池",
                                            "note": "1. 運行時常量池是方法區的一部分\n2. class文件包含：類的版本、字段、方法、接口、常量池表\n3. 常量池表用於存放編譯期生成的各種字面量和符號引用，在類加載後存放到方法區的運行時常量池\n4. 運行期也可以將新的常量放入運行時常量池，即使沒有預置在class文件中，如String.intern()\n5. 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d2gn6a6srp40",
                                            "created": 1720084804028,
                                            "text": "2.2.7 直接內存",
                                            "note": "1. 直接內存不是虛擬機運行時數據區的一部分，也不是Java虛擬機規範中定義的內存區域\n2. JDK1.4新增的NIO可以使用Native函數庫直接分配對外內存，再通過堆裡的DirectByteBuffer對象作為這塊內存的引用進行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n3. 直接內存不受堆大小控制"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d2gn961rvm80",
                                    "created": 1720085030109,
                                    "text": "2.3 HotSpot虛擬機對象探秘"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d2gnh0jzu080",
                                            "created": 1720085645063,
                                            "text": "2.3.1 對象的創建",
                                            "note": "1. 虛擬機接受到new指令\n2. 檢查指令參數是否能在常量池定位一個符號引用\n3. 檢查該符號引用代表的類是否已被加載、解析初始化過，沒有則執行類加載\n4. 類加載通過後開始為新生對象分配內存，所需內存大小在類加載完成即可確定。內存分配可使用指針碰撞（Bump The Pointer）或空閒列表（Free List）的方式\n5. 除分配內存外，還需要考慮並發問題：对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。\n解決方式：\n1. CAS+失敗重試（虛擬機採用這種方式）\n2. 把內存分配根據線程劃分在不同的內存空間中，線程緩衝區使用完了再同步（TLAB）\n\n6. 內存分配完成後，便要分配到的內存（不包括對相投）初始化為零值，，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。保證了java代碼中實例字段即使不賦初值也可使用\n\n7. 對象頭設定，如：類信息、對象哈希碼（調用Object::hashCode()才計算）、GC分代年齡等\n\n8. 執行類的構造函數\n\n\n\n\n",
                                            "layout_right_offset": {
                                                "x": 7,
                                                "y": 1.5
                                            }
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d2i2vs5xgao0",
                                                    "created": 1720230678866,
                                                    "text": "內存分配方式",
                                                    "note": "1. 指針碰撞（Bump The Pointer)\n> 針對規整的內存，所有使用過的內存放在一邊，空閒的內存在另一邊，中間放一個指針作為分界點指示器，此時內存分配就是指針向空閒空間方向移動對象大小的距離\n\n2. 空閒列表（Free List）\n> 針對不規整內存（已使用和空閒內存交錯在一起），虛擬機維護一個空閒列表，記錄哪些內存塊可用，分配時從列表中找出一塊足夠大的空間劃分給對象實例，並更新列表記錄\n\n選擇指針碰撞還是空閒列表取決於java堆是否規整。java堆是否規整由所採用的垃圾收集器是否帶有空間壓縮能力決定。\n如Serial、ParNew有壓縮整理過程，系統採用的分配算法是指針碰撞，簡單高效\nCMS收集器基於清除算法，理論上只能採用較為複雜的空閒列表方式分配內存\n\n强调“理论上”是因为在CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作Linear\nAllocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指\n针碰撞方式来分配。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d2i3uez011s0",
                                                    "created": 1720233392895,
                                                    "text": "內存分配並發問題解決"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d2i3vkf36k00",
                                                            "created": 1720233483116,
                                                            "text": "線程分配緩衝",
                                                            "note": "本地線程分配緩衝（Thread Local Allocation Buffer,TLAB）\n線程需要分配內存時，優先在各自線程的分配緩衝區中分配，只有本地緩衝區用完了，分配新的緩存區時才需要同步鎖定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d2i3vqcgmxs0",
                                                            "created": 1720233496018,
                                                            "text": "CAS+失敗重試",
                                                            "note": "什么是CAS（CAS屬於樂觀鎖）？\nCAS是一种非阻塞式并发控制技术，它主要用于解决多个线程同时访问同一个共享资源时可能出现的竞争条件问题。为了保证数据的一致性和正确性，我们通常需要采取同步机制来对共享资源进行加锁。但是，传统的锁机制在高并发场景下会带来严重的性能问题，因为所有线程都需要等待锁的释放才能进行操作，这就会导致大量线程的阻塞和唤醒，进而降低了系统的并发性能。\n为了解决这个问题，CAS应运而生。它是一种无锁的同步机制，可以在不使用锁的情况下实现数据的同步和并发控制。CAS的核心思想是：在执行操作之前，先比较当前内存中的值是否等于期望值，如果相等，则执行修改操作；如果不相等，则不执行修改操作，继续进行比较，直到内存中的值与期望值相等为止。这个过程中不会出现线程的阻塞和唤醒，因此可以提高系统的并发性能。\n\n* 开销问题\n>在 CAS 期间，线程是不会休息的，线程如果长时间无法提交，内部就一直在进行自旋，这样就会产生比较大的内存开销\nCAS 只能够保证一个共享变量的原子操作\nCAS 只能保证对一个内存地址进行原子操作，所以说使用范围会有一定限制\n例如：如果在执行 a+1 的下面加上，b+1，c +1，这种情况就会出现问题，这种时候反而使用 Syn 比较方便\n多個變量的院子操作可考慮Java的AtomicReference"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "d2i222zx0ig0",
                    "created": 1720228351523,
                    "text": "虛擬機性能相關參數",
                    "layout_mind_offset": {
                        "x": 28,
                        "y": 0
                    },
                    "note": "1. 本地線程分配緩衝"
                },
                "children": [
                    {
                        "data": {
                            "id": "d2i24vfkhlc0",
                            "created": 1720228570147,
                            "text": "本地線程分配緩衝",
                            "note": "本地線程分配緩衝（Thread Local Allocation Buffer,TLAB）\n線程需要分配內存時，優先在各自線程的分配緩衝區中分配，只有本地緩衝區用完了，分配新的緩存區時才需要同步鎖定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。"
                        },
                        "children": []
                    }
                ]
            }
        ]
    },
    "template": "default",
    "theme": "fresh-blue",
    "version": "1.4.43"
}