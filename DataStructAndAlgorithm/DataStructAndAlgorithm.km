{
    "root": {
        "data": {
            "id": "d60bnopxpq00",
            "created": 1733051988985,
            "text": "数据结构与算法",
            "note": "参考：\n数据结构与算法分析-java语言描述（第三版）\n作者：Mark Allen Weiss"
        },
        "children": [
            {
                "data": {
                    "id": "d60bo5qn9i00",
                    "created": 1733052026033,
                    "text": "树",
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "id": "d60bod3iesg0",
                            "created": 1733052042049,
                            "text": "遍历"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d60bof0phx40",
                                    "created": 1733052046233,
                                    "text": "前序遍历"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d60boialz9k0",
                                    "created": 1733052053362,
                                    "text": "中序遍历"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d60bokea1340",
                                    "created": 1733052057937,
                                    "text": "后序遍历"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d60bqro52nc0",
                            "created": 1733052230499,
                            "text": "二叉树"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d60bxcmn6jc0",
                                    "created": 1733052746306,
                                    "text": "表达式树",
                                    "note": "1. 理解构建表达式树的方法\n\n3种表达式:\n前缀表达式：由树的前序遍历生成的结果\n中缀表达式：由树的中序遍历生成的结果\n后缀表达式：由树的后序遍历生成的结果"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d60c5iqx8mo0",
                                    "created": 1733053386539,
                                    "text": "二叉查找树",
                                    "note": "定义：对于节点X，它的所有左子树的值均小于X，它的所有右子树的值均大于X。\n\nQ: 有相等值怎么办？\n\n二叉查找树平均深度：O(logN)\n\n二叉查找树要求所有项都可以排序，故而二叉查找树的项要实现比较功能或使用函数对象"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d60e84yqbhk0",
                                            "created": 1733059233849,
                                            "text": "实现"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d60e870pci00",
                                                    "created": 1733059238321,
                                                    "text": "contains",
                                                    "note": "contains方法用于判断存在，若树T含有项X，则返回true，否则返回false；\n若T为空则返回false\n若根节点为X则返回true\n其余情况对左右子树作一次递归调用\n因二叉查找树的平均深度为O(logN),所以递归调用时最大栈深为O(logN)"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d60ebv4k2lc0",
                                                    "created": 1733059525890,
                                                    "text": "finMin findMax",
                                                    "note": "查找最大最小值，即查找树的最左和最右节点，注意空值判断"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d60ed5wxfrs0",
                                                    "created": 1733059627737,
                                                    "text": "insert",
                                                    "note": "插入若遇重复值，可不作处理或在该节点增加次数标记；\n增加标记的好处：减少树深，删除时相应减标记值，不移除节点，下次再有该重复值，不用重新分配节点\n\n\n重复值处理方法：\n1. 节点增加出现次数标记值\n2. 新增数据结构维护重复值，如表或新的查找树"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d60eh38r9k80",
                                                    "created": 1733059935379,
                                                    "text": "remove",
                                                    "note": "1. 删除项没有子节点，直接移除\n2. 删除项有1个子节点，变更父节点的指向后删除节点\n3. 有2个节点：使用左子树最大值或右子树最小值覆盖删除节点\n\n\n若删除次数不多，通常使用惰性删除：\n当一个节点删除时，节点仍保留在树中，标记为删除。有重复值时很常用，一次删除标记-1。好处是下次再插入时不用重新分配节点"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d60ekx60crc0",
                                                    "created": 1733060235609,
                                                    "text": "平均情况",
                                                    "note": "平均情况下任意节点的预期深度为O(logN)。推导参考4.3.5\n上述推导不完全正确，原因在删除操作，若删除时每次都取右子节点最小值覆盖删除节点，那么会导致左右子树失衡，降低查找树的效率。\n解决方法：\n1. 删除时随机选取左子树最大值和右子树最小值覆盖删除节点，降低失衡概率\n2.实现平衡算法（如AVL树）\n3. 放弃平衡条件，允许任意深度，但每次操作后要使用一个规则进行调整（自调整 self-adjusting），以提高后面的操作效率，这种数据结构称作伸展树（splay tree）"
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "d60euvq4ziw0",
                                            "created": 1733061016114,
                                            "text": "AVL树",
                                            "note": "实现关键：\n1. AVL树实现类包含节点值，左节点、右节点和节点深度\n2. AVL树插入用递归实现，同时在返回时对子树作Rebalance。\n3. 删除操作与一般查找树删除多一步：返回时对该子树作rebalance"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d630srmebs00",
                                                    "created": 1733326034783,
                                                    "text": "定义",
                                                    "note": "一棵AVL树是其每个节点的左子树和右子树的高度差不超过1的二叉查找树（空树的高度为-1）\n\n粗略的说，一个AVL树的高度最多为1.44log(N+2)-1.328,但实际上的高度只略大于logN\n\n在高度为h的AVL树中，最少的节点树S(h)由S(h)=S(h-1)+S(h-2)+1给出。对于h=0,S(h)=1;H=1,S(h)=2。函数S(h)和斐波那契数列密切相关。\n\n除去可能的插入外（假设懒惰删除），所有的AVL树操作都可以用时间0(logN)执行。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "d630zghrkcg0",
                                                    "created": 1733326559108,
                                                    "text": "AVL树的重平衡",
                                                    "note": "插入操作可能会引起AVL树的失衡，需要通过旋转来达到重平衡的目的\n\n插入情景：\n设需要重平衡的点为a，则插入情景如下：\n1. 在a的左儿子的左子树插入\n2. 在a的左儿子的右子树插入\n3. 在a的右儿子的左子树插入\n4. 在a的右儿子的右子树插入\n其中，1、4等价，2、3等价\n\n失衡情景：\n1. 插入发生在外边（左-左或右-右的情况）\n2. 插入发生在内部（左-右或右-左情况）\n\n```\n左-右，右-左情形其实就是新插入的点大小在父节点和爷爷节点之间\n```"
                                                },
                                                "children": [
                                                    {
                                                        "data": {
                                                            "id": "d6316ol9ef40",
                                                            "created": 1733327125283,
                                                            "text": "单旋转",
                                                            "note": "参考MarkDown"
                                                        },
                                                        "children": []
                                                    },
                                                    {
                                                        "data": {
                                                            "id": "d6316utaj940",
                                                            "created": 1733327138829,
                                                            "text": "双旋转",
                                                            "image": "",
                                                            "imageTitle": "",
                                                            "imageSize": "",
                                                            "note": "参考MarkDown"
                                                        },
                                                        "children": []
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d60c5bvic7c0",
                            "created": 1733053371579,
                            "text": "B树",
                            "note": "上述我们都假设数据结构存储在内存中，但数据量很大的时候，内存装不下，只能选择磁盘存储。此时大O模型不再使用（因为大O模型建立在所有操作耗时都相等的假设上，磁盘不满足该假设，特别是涉及I/O时）。\n\nB树通过增加节点分支，达到减少高度，从而降低磁盘访问次数的目的\n\n\nB树优点：\n1. 磁盘存储，没有内存空间限制\n2. 可数次数的磁盘访问便可实现大数据量的检索"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d6ipc05rta80",
                                    "created": 1734918648276,
                                    "text": "CPU与磁盘速度对比",
                                    "note": "以500MIPS（Millions Instructions Per Second）的机器为例，每秒CPU可执行5亿条指令，速度相当快，原因是速度只要依赖于电的特性。磁盘依赖机械运动，包含转动磁盘和移动磁头的时间。以7200RPM（Rounds Per Minute）磁盘为例1转占用1/120秒，即8.3毫秒。平均认为磁盘转到一半可找到需要的信息，但磁头移动也耗时，相互抵消，故而，粗略估计访问时间为8.3毫秒，因此每秒可以进行120次磁盘访问。\n对比CPU速度，一次磁盘访问的价值约为40W条指令。因此，为了减少磁盘访问，我们愿意进行大量的计算"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d6iq5ftee400",
                                    "created": 1734920954917,
                                    "text": "B树特性",
                                    "note": "M阶的B树（B+树）是具有如下特性的一棵树：\n1. 数据项存储在树叶上。\n2. 非叶子节点存储直到M-1个关键字以指示搜索的方向；关键字i代表子树i+1中的最小的关键字\n3. 树的根或者是一片树叶，或者其儿子树在2和M之间\n4. 除根外，所有非树叶节点的儿子树在M/2（向上取整）和M之间\n5. 所有树叶都在相同的深度；并有L/2（向上取整）和L之间个数据项，L的确定参考后续。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d6iqebax81c0",
                                    "created": 1734921650370,
                                    "text": "M和L的确定",
                                    "note": "例子：佛罗里达州公民的驾驶记录，共1千万项，每个关键字是32字节（名字），一个记录是256字节。\n\n假设一个区块能容纳8192字节。如上，一个关键字32字节。M阶B树有M-1个关键字，共32M-32字节，再加上M个分支。由于每个分支基本都是另外的磁盘区块，因此假设一个分支是4字节。这些分支共有4M个字节。一个非叶子节点总内存需求为36M-32字节。使得不超过8192的最大M为228。因此，我们选择M=228。由于每个数据有256字节，因此可以把32个记录装入一个区块中。于是，选择L=32。由于有1千万个记录，最多有625 000片树叶。由此，最坏情形下，树叶在第4层。最坏情形的访问次数由近似$log_(M/2)N$给出，这个数可以有1的误差（例如可以把根和下一层放入主存，以减少磁盘访问次数）"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d6iqmreuudc0",
                                    "created": 1734922312350,
                                    "text": "B树的插入和删除",
                                    "note": "参考markdown"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d6ivpcnmy740",
                            "created": 1734936620871,
                            "text": "TreeSet TreeMap"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d6ivpt4hqbs0",
                                    "created": 1734936656719,
                                    "text": "线索树"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d6ivpijueww0",
                            "created": 1734936633703,
                            "text": "小结",
                            "note": "1. 表达式树是分析树（parse tree）的一个小例子，分析树是编译器设计的核心数据结构，分析树不是二叉树，而是表达树相对简单的扩充（建立分析树的算法并不简单）\n2. 查找树在算法设计中非常重要，几乎支持所有操作，对数时间的平均开销很小。查找树非递归实现要快一些，但递归实现更巧妙，更易懂，更易于差错。查找树的问题在于依赖输入，而输入是随机的。极端情况查找树会成为昂贵的链表\n3. AVL树处理了查找树依赖输入的问题，左右子树高度差不大于1，保证了树不会太深。改变树的操作必须将树恢复（插入操作，及非懒惰的删除操作）。\n4. 伸展树中的节点可以达到任意深度，但是每次访问后树会被调整，达到连续M次操作花费O(MlogN)时间，与平衡树花费相同，适合有热点数据的情景使用。\n5. B树是平衡M路树，很好地适应磁盘操作情况。\n6. 查找树的中序遍历会得到排过序的元素，这给出排序的一种O(NlogN)算法。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "d6iw08tfq140",
                    "created": 1734937474521,
                    "text": "散列",
                    "note": "放入散列表中的對象需事先equals和hashcode方法。\n\n重要概念：\n**裝填因子λ為散列表中的元素個數對該表大小的比**",
                    "expandState": "expand"
                },
                "children": [
                    {
                        "data": {
                            "id": "d6lb73lersg0",
                            "created": 1735183448262,
                            "text": "一般想法",
                            "note": "將一組關鍵字通過某個算法分配到表中，同時提供衝突解決方案"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d6lb7sxqr2w0",
                            "created": 1735183503428,
                            "text": "散列函數",
                            "note": "散列函數注意事項：\n1. 表大小最好是素數\n2. 盡量保證關鍵字在表中的均勻分配\n3. 注意散列函數的計算速度\n4. 提供衝突解決方案"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d6lbbr67dls0",
                            "created": 1735183813042,
                            "text": "衝突解決方案"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d6lbburpmcg0",
                                    "created": 1735183820873,
                                    "text": "分離鏈接法(Seperate Chaining)",
                                    "note": "散列表的每一項均為一個鏈錶（也可為二叉查找樹或二級散列表）\n注意：如果插入的是一個新元素，那麼將它插入到鏈錶前端，這更方便，同時，新近插入的元素最有可能在不久後被訪問。\n\n優點：\n1. 易於實現\n2. 散列函數簡單\n3. 裝填因子較高（一般設為1）\n\n缺點：\n1. 使用鏈錶，給新元素分配地址需要時間，導致算法速度有所減慢。\n2. 要求第二種數據結構的實現（鏈錶）"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d6lf4v0wi7s0",
                                            "created": 1735194557320,
                                            "text": "效率分析",
                                            "note": "我們定義散列表的裝填因子λ為散列表中的元素個數對該表大小的比。在書中例子中，λ=1.0。鏈錶的平均長度為λ。執行一次查詢所需要的工作是計算散列函數值所需的常數時間和遍歷鏈錶所用的時間。\n\t在一次不成功的查找中（散列表中沒有該元素），要搜索的節點數平均為λ。\n\t一次成功的查找需要大約遍歷1+(λ/2)個節點。\n\n成功查找遍歷效率分析：\n注意被搜索的鏈錶包含1個匹配節點和0個或多個其它節點。在N個元素、M個鏈錶的散列表中，“其它節點”的期望個數為(N-1)/M=λ-1/M，因為假設M是大的（散列表高效的前提），該值近似=λ。\n平均來看，鏈錶中有一般“其它節點”被搜索到，再加上匹配節點，得到1+λ/2個節點的平均查找代價。\n\n上述分析指出，散列表的效率和散列表的大小無關，與裝填因子密切相關。\n**分離鏈接法使得表大小和預期元素個數大致相等（即λ約等於1）**。若裝填因子超過1，需要使用rehash函數為散列表擴容。"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d6lfq3xzue00",
                                    "created": 1735196222382,
                                    "text": "探測散列表(Probing Hash Table)",
                                    "note": "散列表元素不分裂，而是嘗試表中另外的單元，知道找出空單元為止。常見的是，h_0(x),h_1(x),h_2(x)...相繼被試選，其中h_i(x) = (hash(x) + f(i)) mod TableSize，且f(0)=0。函數f是衝突解決方法。\n因為所有數據都要置入表內，所以這種方案對表大小的要求比分離鏈接法大。一般來說，λ應低於0.5。\n\n注：探測散列表方式標準刪除操作不可用，因為單元可能曾經引起衝突，已被insert到其它位置，需使用惰性刪除：使用標誌位標明該位置是否被刪除"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d6lgaw8vsyo0",
                                            "created": 1735197851274,
                                            "text": "線性探測法",
                                            "note": "線性探測法中，函數f是i的線性函數，典型為f(i)=i。相當於若發生衝突，逐個向下找空單元（必要時可回繞散列表）\n\n效率：\n\n插入/不成功的查找需要的探測次數：\n1/2 * (1+1/(1-λ)^2）\n成功查找需要探測次數：\n1/2 * (1+1/(1-λ))\n\n相關計算較複雜，不詳述。但不難看出，插入和不成功的查找花費的時間是一樣的，同時，成功查找比不成功查找花費較少時間。\n\n隨機衝突解決方法和線性探測方法效率對比：\n參見書籍pdf\n\n優點：\n\n1. 算法簡單\n2. 在λ<=0.5時，平均插入操作只要2.5次探測，平均成功查找只需要1.5次探測\n\n缺點：\n\n1. 會發生數據聚集，導致每次插入都要多次探測才能插入（一次聚集）\n2. λ>0.5時，線性探測插入和查找花費的探測次數將大大增加。\n3. 單元利用率低\n\n\n使用指南：\n\n1. 在λ達到0.5時擴容\n"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d6lialigt0o0",
                                            "created": 1735203470128,
                                            "text": "平方探測法",
                                            "note": "衝突解決函數（例子）：f(i)=i^2\n\n平方探測需要留1半的空間作衝突備選（注意散列定理一）\n\n\n優點：\n\n1. 沒有線性探測的一次聚集問題\n\n缺點：\n\n1. 二次聚集（散列到同一位置的元素會探測相同的備選單元）\n\n雙散列可解決平方探測二次聚集問題\n\n\n1. 注意平方探測的快速方法（文檔P127末尾）\n"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d6rgfc5uvhs0",
                                            "created": 1735807559116,
                                            "text": "雙散列",
                                            "note": "衝突解決函數（例子）：f(i)= i*hash_2(x)\n當發生衝突時使用第二個衝突解決函數解決衝突\n\n\n\n優點：\n\n1. 理論上具有和隨機衝突解決方法相同的探測次數\n\n缺點：\n\n1. 對比平方探測，雙散列需要第二個散列函數，實踐中更慢，特別在hash計算耗時的字符串關鍵字"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d6rgnl03eog0",
                            "created": 1735808205272,
                            "text": "再散列",
                            "note": "散列表元素過滿時，為避免性能下降，需要新建一個新的散列表（約為2倍大），掃描原散列表，將每個未刪除的元素用新的散列函數插入到新錶中\n\n\n再散列是開銷非常大的操作，運行時間為O(N)。\n\n再散列操作在交互式系統中會使用戶感到速度減慢\n\n再散列策略：\n\n1. 半滿時觸發\n2. 插入失敗時觸發\n3. 達到裝填因子後觸發（散列表性能與裝填因子相關，此方法可能是最好的策略）\n\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "d6sanklanjc0",
                            "created": 1735892837674,
                            "text": "最壞情況下O(1)訪問的散列表",
                            "layout_right_offset": {
                                "x": 3,
                                "y": -2
                            },
                            "note": "目前我们讨论的散列表都具有的性质是，当有合理的装填因子和合适的散列函数时，可以期望插入、删除和查找的平均花销都是O(1)。那最坏情形的期望值是多少？\n\n球盒问题：\n给定N个球，均匀随机地放在N个盒子中，在装球最多的盒子里，求得个数的期望值是θ（logN/loglogN）\n\n即平均而言，我们期望部分查询会花费近乎对数级的时间。\n\n我们希望得到O(1)的最坏情形花销，本节会给出解法"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d6sbirwfaps0",
                                    "created": 1735895282874,
                                    "text": "完美散列",
                                    "note": "存在二级散列表的散列表\n定义：\n\n1. 主散列表有N个表\n2. 二级散列表表个数为hash到该二级散列表元素个数的平方\n\n定理二和定理三与完美散列相关\n\n在事先知道所有项的情况下，完美散列是好用的。还有一些动态方法允许插入和删除（动态完美散列）"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d6sbqjs415c0",
                                    "created": 1735895892112,
                                    "text": "布谷鸟散列(CuckooHashTable)"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d6sxwdbvmu00",
                                            "created": 1735958412673,
                                            "text": "定义",
                                            "note": "在布谷鸟散列中，假设有N项。我们会维护两个（可多个）分别超过半空的表，且有两个（可多个）独立的散列函数，可以把每个项分配到其中一个表的一个位置中。布谷鸟散列保持不变的是一个项总会被存储在其中一个表的位置中\n\n\n布谷鸟散列在插入时若发现目标位置已有元素，则先移除原有元素，直接插入新元素。再把原有元素放到其它散列表中再散列。若插入发生死循环，则创建新的散列函数对原有散列表作再散列。\n\n若装填因子小于0.5，死循环出现概率非常小，替换次数也是一个小的常数。装填因子大于0.5时，死循环出现概率会大幅增加。\n\n单次插入发生死循环的概率约为O(1/N^2)"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d6sxyinha2w0",
                                            "created": 1735958580986,
                                            "text": "经典变种实现",
                                            "progress": 8,
                                            "note": "完善markdown截图，该变种让所有hash函数在同一个数组中做散列"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "d6umzdkbuqw0",
                                                    "created": 1736130735981,
                                                    "text": "insert",
                                                    "note": "关键点：\n\n1. 尝试所有hash函数，若有空位置，直接插入\n2. 若无空位，则随机使用一个hash函数找出一个位置（若与上次随机位置一致，重新随机，同时控制随机次数），替换其中的值，被替换的值按新插入元素处理\n3. 若插入发生太多次循环（死循环），则扩表或使用新hash函数"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "d6uowrn9ps00",
                                    "created": 1736136173761,
                                    "text": "跳房子散列",
                                    "note": "跳房子散列是经典线性探测算法的改进尝试。在经典线性探测算法中，会存在一次和二次聚集，序列探测长度随着表的装载而变长，于是改进的平方探测、双散列被提出，试图降低冲突次数。\n\n跳房子散列的思路是用事先确定的、对计算机底层体系结构而言最优的一个常数（MAX_DIST），给探测长度加上一个界。这样做可以给出常数时间的最坏查询时间。并且和布谷鸟散列一样，查询可以并行化，以同时检查可用位置的有限集。\n\n现假设MAX_DIST=4，abcd为顺序且连续的4个位置，若散列到位置a的个数已满4个，若再有多余散列到位置a的元素进来，显然不能插入成功（因为我们已经限制了散列到a的元素只能存在abcd4个位置）\n\n通常情况下装填因子超过0.9才需要再散列，装填因子小于0.5几乎不会发生插入失败"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d6voqth0flk0",
                                            "created": 1736237267507,
                                            "text": "insert",
                                            "note": "设MAX_DIST=4\n\n当前散列表元素如下\n设d的散列值为1，那么d可以放在1-4的位置，若4个位置有空，可直接插入\n\n如下表，I的散列值为6，发现往下找只有14有空位，离6的距离超过MAX_DIST，故而，需要从后向前查找是否可以有元素可以插到14的位置，同时不打破跳房子散列的规则，详情可参考文档P145（补到markdown）\n\n\n||element|Hop|\n|--|--|--|\n|...|\n|6|C|1000|\n|7|A|1100|\n|8|D|0010|\n|9|B|1010|\n|10|E|0000|\n|11|H|0010|\n|12|F|1000|\n|13|G|0000|\n|14||0000|\n|...|",
                                            "progress": 8
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d6liawjdgdc0",
                            "created": 1735203494128,
                            "text": "散列定理"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d6lib42q2140",
                                    "created": 1735203510535,
                                    "text": "定理一",
                                    "note": "**如果使用平方探測，且表大小是素數，那麼當表至少有一半是空的時候，總能夠插入一個新的元素**\n\n\n證明參考markdown(待補充)\n\n\n",
                                    "progress": 8
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d6sat24a8uo0",
                                    "created": 1735893267649,
                                    "text": "定理二",
                                    "note": "若N个球被放入M=N^2个盒子，则没有任何盒子有超过1个球的概率不小于1/2\n\n证明参考文档P134",
                                    "progress": 8
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d6sbf8h15sg0",
                                    "created": 1735895005492,
                                    "text": "定理三",
                                    "note": "若N个项被放入包含N个盒子的主散列表中，则二级散列表的总容量的期望值最多是2N\n\n证明参考文档P134",
                                    "progress": 8
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d71gwzzo12g0",
                                    "created": 1736824542742,
                                    "text": "定理四",
                                    "note": "散列族H = {H_(a,b)(x) = ((ax+b) mod p) mod M，其中 1<=a<=p-1，0<=b<=p-1} 是通用的\n\nMarkDown中补充证明，证明未理解",
                                    "progress": 8,
                                    "priority": null
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d70tkv0ov2o0",
                            "created": 1736758706022,
                            "text": "通用散列法",
                            "note": "好的散列函数取决于以下两个性质：\n\n1. 散列函数必须可在常数时间（即与表中项的个数无关）内计算\n2. 散列函数必须将各项均匀分布在数组单元中"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d70tqjyw4m80",
                                    "created": 1736759152154,
                                    "text": "通用定义",
                                    "note": "M表示TableSize"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "d70tqsxgots0",
                                            "created": 1736759171658,
                                            "text": "5.1",
                                            "note": "如果对任意x<>y，H中有h(x)=h(y)的散列函数h的个数至多为|H|/M，则一个散列函数族H是通用的\n\n\n解释：\n如果从一个通用族H中随机取一个散列函数，则任意两个不同的项之间发生冲突的概率最多是1/M，并且向表中加入N个项时，在起始点发生冲突的概率至多是N/M，或者是装填因子\n\n\n该类散列函数适合分离链接法和跳房子散列"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "d71h6ophwls0",
                                            "created": 1736825301824,
                                            "text": "5.2",
                                            "note": "如果对任意x1<>y1, x2<>y2, ..., xk<>yk，H中有h(x1)=h(y1), h(x2)=h(y2),..., h(xk)=h(yk)的散列函数h的个数至多为|H|/M^2，则一个散列函数族H是k-通用的\n\n\n\n\n该类散列函数适合布谷鸟散列，定理四为符合该定义的一个例子"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d71o80yw1eg0",
                            "created": 1736845154647,
                            "text": "可扩散列"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "d6z1vg246c00",
                    "created": 1736578984428,
                    "text": "排序算法",
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "id": "d6z1vlb9chk0",
                            "created": 1736578995865,
                            "text": "选择排序"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d6z1vxoqot40",
                                    "created": 1736579022802,
                                    "text": "优化",
                                    "note": "每次找出最大和最小值"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d6z1vq75w8w0",
                            "created": 1736579006501,
                            "text": "冒泡排序"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d6z1wevxaxc0",
                                    "created": 1736579060241,
                                    "text": "优化",
                                    "note": "减少对已排序的元素重排序，每轮循环增加一个标志位，若一轮中都没有元素移动，说明元素已经是有序的，结束排序"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d6z1vt7u9740",
                            "created": 1736579013073,
                            "text": "插入排序"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d6z1xtqcmog0",
                                    "created": 1736579170920,
                                    "text": "原理",
                                    "note": "每次插入由后往前比较，找出元素应该存放的位置，然后做插入"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "d6z1xwsgfaw0",
                                    "created": 1736579177578,
                                    "text": "优化",
                                    "note": "1. 对已排好序的序列，采用二分查找法\n2. 每次插入携带多个元素，减少数组元素移动次数\n3. 数据链表化\n4. 希尔排序"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "d6z2721ne340",
                            "created": 1736579894295,
                            "text": "希尔排序",
                            "note": "希尔排序"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "d6z29y67y340",
                                    "created": 1736580120957,
                                    "text": "原理",
                                    "note": "希尔排序是对插入排序的优化，通过将数列分为若干组，对每组作插入排序处理，然后更换分组方式，再执行插入排序，使数列大致有序，最后再对所有元素进行一次插入排序，达到全部有序的目的\n\n核心思想化远为近，减少查找次数，减少移动元素次数"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "template": "right",
    "theme": "fresh-blue",
    "version": "1.4.43"
}